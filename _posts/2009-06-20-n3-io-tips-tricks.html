---
layout: post
title: N3 I/O Tips & Tricks
date: '2009-06-20T15:38:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2009-06-20T15:38:52.421+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-1307034525555320497
blogger_orig_url: http://flohofwoe.blogspot.com/2009/06/n3-io-tips-tricks.html
---

<p>Note: all of the following code-fragments assume:</p>  <blockquote>   <p><font face="Courier New">using namespace Util;        <br />using namespace IO;         <br /></font></p> </blockquote>  <h4>Working with Assigns</h4>  <p>Assigns are path aliases which are used instead of hardwired file locations. This lets an N3 application use filenames which are independent from the host platform, actual Windows version, or Windows language version. The following “system assigns” are pre-defined in a standard Nebula3 application:</p>  <ul>   <li><strong>home:</strong> Points to the app’s installation directory, or (on console platforms) the root directory of the game content. The home: location should always be treated as read-only! </li>    <li><strong>bin: </strong>Points to the location where the app’s executable resides, should be treated as read-only (not available on console platforms) </li>    <li><strong>user: </strong>On Windows, points to the logged-in user’s data directory (e.g. on Windows 7 this is c:\Users\[user]\Documents). Can be treated as read/write, and this is where profile-data and save-game-files should be saved. On consoles this assign may point to the save-location, or it may not be available at all (if saving game data is not handled through some sort of file system on that specific platform). </li>    <li><strong>temp: </strong>On Windows, this points to the logged-in user’s temp directory (e.g. on Windows 7 this is c:\Users\[user]\AppData\Local\Temp). This directory is read/write but applications should assume that files in this directory may disappear at any time. This assign is not available on console platforms. </li>    <li><strong>programs: </strong>On Windows, this points to the standard location for programs (e.g. “c:\Program Files”) </li>    <li><strong>appdata: </strong>On Windows, this points to the user’s AppData directory (e.g. c:\Users\[user]\AppData) </li> </ul>  <p>Additionally to these system assigns, Nebula3 sets up the following “content assigns” at startup which all applications can rely on:</p>  <ul>   <li><strong>export:</strong> points to the root of the directory where all game data files reside       <ul>       <li><strong>ani: </strong>root directory of animation files </li>        <li><strong>data:</strong> root directory of general data files </li>        <li><strong>video:</strong> root directory of movie files </li>        <li><strong>seq: </strong>root directory of sequence files (e.g. engine-cutscenes) </li>        <li><strong>stream:</strong> root directory of streaming audio files </li>        <li><strong>tex: </strong>root directory of texture files </li>        <li><strong>frame:</strong> root directory of frame shader files </li>        <li><strong>mdl:</strong> root directory of .n3 files </li>        <li><strong>shd: </strong>root directory of shader files </li>        <li><strong>audio:</strong> root directory for non-streaming audio files </li>        <li><strong>sui:</strong> root directory for “Simple GUI” scene files </li>     </ul>   </li> </ul>  <p>More standard assigns may be added in the future.</p>  <p>An application can define its own assigns or override existing assigns using the IO::AssignRegistry singleton:</p>  <blockquote>   <p><font face="Courier New">AssignRegistry::Instance()-&gt;SetAssign(Assign(“bla”, “home:blub”));</font></p> </blockquote>  <p><font face="Ver">To use the new assign, simply put it at the beginning of a typical file path:</font></p>  <blockquote>   <p><font face="Courier New">“bla:readme.txt”</font></p> </blockquote>  <p>This would resolve to the following absolute filename (assuming your app is called “MyApp” and located under the standard location for programs under Windows):</p>  <blockquote>   <p>“C:\Program Files\MyApp\blub\readme.txt”</p> </blockquote>  <p>You can resolve a path name with assigns into an absolute file name through the AssignRegistry, this is usually necessary when working with 3rd party libs:</p>  <blockquote>   <p><font face="Courier New">String absPath = AssignRegistry::Instance()-&gt;ResolveAssignsInString(“bla:readme.txt”);</font></p> </blockquote>  <p>Finally, Assigns are not restricted to file system locations:</p>  <blockquote>   <p><font face="Courier New">AssignRegistry::Instance()-&gt;SetAssign(Assign(“bla”, “http://www.radonlabs.de/blub”));</font></p> </blockquote>  <p>&#160;</p>  <h4>Listing directory content</h4>  <p>You can list the files or subdirectories of a directory with pattern matching like this:</p>  <blockquote>   <p><font face="Courier New">// list all files in the app’s export directory        <br /></font><font face="Courier New">Array&lt;String&gt; files = IoServer::Instance()-&gt;ListFiles(“home:export”, “*”);</font></p>    <p><font face="Courier New">// list all subdirectories in the app’s export directory        <br />Array&lt;String&gt; dirs = IoServer::Instance()-&gt;ListDirectories(“home:export”);</font></p>    <p><font face="Courier New">// list all DDS textures of category “leafs”        <br />Array&lt;String&gt; leafTextures = IoServer::Instance()-&gt;ListFiles(“tex:leafs”, “*.dds”);</font></p> </blockquote>  <p>Note that the returned strings are not full pathnames, only the actul file- and directory-names!</p>  <h4>&#160;</h4>  <h4>Working with directories</h4>  <p>You can create directories and subdirectories with a single method call:</p>  <blockquote>   <p><font face="Courier New">IoServer::Instance()-&gt;CreateDirectory(“home:bla/blub/blob”);</font></p> </blockquote>  <p>This will also create all missing subdirectories as needed.</p>  <p>You can delete the tail directory of a path, but the directory must be empty:</p>  <blockquote>   <p><font face="Courier New">IoServer::Instance()-&gt;DeleteDirectory(“home:bla/blub/blob”);</font></p> </blockquote>  <p>This will delete the “blob” subdirectory only, and only if there are no files or subdirectories left under “blob”.</p>  <p>You can check whether a directory exists:</p>  <blockquote>   <p><font face="Courier New">if (IoServer::Instance()-&gt;DirectoryExists(“home:bla/blub”))        <br />{         <br />&#160;&#160;&#160; // directory exists         <br />}</font></p> </blockquote>  <p>NOTE:</p>  <ul>   <li>creating and deleting directories in archive files doesn’t work </li>    <li>all directory functions only work in the file system, so a DirectoryExists(“http://www.radonlabs.de/bla”) will *not* work </li> </ul>  <h4>&#160;</h4>  <h4>Working with files</h4>  <p>The following IoServer methods are available for files, these all work directly with path names, so you don’t need to have an actual Stream object around:</p>  <blockquote>   <p><font face="Courier New">// check whether a file exists:        <br />if (IoServer::Instance()-&gt;FileExists(“home:readme.txt”)) …         <br /></font><font face="Courier New"></font></p>    <p><font face="Courier New">// delete a file:        <br />IoServer::Instance()-&gt;DeleteFile(“home:readme.txt”);</font></p>    <p><font face="Courier New">// copy a file:        <br />IoServer::Instance()-&gt;CopyFile(“home:src.txt”, “home:dst.txt”);</font></p>    <p><font face="Courier New">// check if the read-only flag is set on a file:        <br />if (IoServer::Instance()-&gt;IsReadOnly(“home:src.txt”)) …</font></p>    <p><font face="Courier New">// set the read-only flag on a file:        <br />IoServer::Instance()-&gt;SetReadOnly(“home:src.txt”);</font></p>    <p><font face="Courier New">// getting the last modification time of a file:        <br />FileTime fileTime = IoServer::Instance()-&gt;GetFileWriteTime(“home:readme.txt”);</font></p>    <p><font face="Courier New">// setting the last modification time of a file:        <br />IoServer::Instance()-&gt;SetFileWriteTime(“home:readme.txt”, fileTime);</font></p> </blockquote>  <p>NOTE:</p>  <ul>   <li>DeleteFile(), SetReadOnly(), SetFileWriteTime() do not work in file archives </li>    <li>CopyFile() doesn not work if the destination is located in a file archive </li>    <li>all of these functions only work with file system paths (not “http://…”) </li> </ul>  <h4></h4>  <h4>&#160;</h4>  <h4>How to get the size of a file</h4>  <p>Currently, the only way to query the size of a file is through an open IO::Stream object. This may change in the future though.</p>  <blockquote>   <p><font face="Courier New">Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“home:readme.txt”);        <br />if (stream-&gt;Open())         <br />{         <br />&#160;&#160;&#160; Stream::Size fileSize = stream-&gt;GetSize();         <br />&#160;&#160;&#160; stream-&gt;Close();         <br />}</font></p> </blockquote>  <p>&#160;</p>  <h4>Working with file archives</h4>  <p>You can mount zip archives as an overlay over the actual file system:</p>  <blockquote>   <p><font face="Courier New">IoServer::Instance()-&gt;MountArchive(“home:archive.zip”);</font></p> </blockquote>  <p>All file system accesses will first check mounted archives (in mount order) before falling back to the actual file system.</p>  <p>Archives have the following restrictions:</p>  <ul>   <li>writing to archives is not supported</li>    <li>the archive filesystem will keep some sort of table-of-content in memory as long as an archive is mounted, the actually required size of the TOC differs by platform.</li>    <li>in the current zlib-based implementation, complete files are decompressed into memory, thus opening a 100 MB file from an archive will also allocate 100 MB of memory until the file is closed </li>    <li>for the above reason, streaming from archive files doesn’t make sense, thus things like streaming audio wave banks or movie files should not be placed into archive files </li> </ul>  <p>On console platforms platform-native file archive formats are used if available (e.g. .PSARC on PS3 or .ARC on Wii) which usually have less restrictions and are better optimized for the platform then plain ZIP support. The Xbox360 port currently uses the standard zlib implementation but this will very likely change in the future.</p>  <p>On Windows (and currently Xbox360), zip support is handled through zlib.</p>  <p>You can add support for other archive formats by deriving subclasses from the classes under foundation/io/archfs, but currently it is not possible to mix different archive formats in one application (because you need to decide on a specific archive-filesystem-implementation at compile-time).</p>  <p>You can turn off the archive file-system layer completely through IoServer::SetArchiveFileSystemEnabled(false). All file accesses will then go directly into the actual file system. This is useful for tools which need to make sure that they don’t accidently read data from an archive file.</p>  <p>Nebula3 defines a “standard archive” where all game data is located. The data in the archive is located under the “export:” assign on all platforms. The actual archive filenames for the various platforms are:</p>  <ul>   <li>Win32: <strong>home:export_win32.zip</strong> </li>    <li>Xbox360: <strong>home:export_xbox360.zip</strong> </li>    <li>Wii: <strong>home:export_wii.arc</strong> </li>    <li>PS3: <strong>home:export_ps3.psarc</strong> </li> </ul>  <p>The <strong>archiver3.exe</strong> tool takes care about generating those standard archives as part of the build process, when generating data for console platforms, the actual console SDK must be installed </p>  <p>(however, please note that we cannot currently license the N3 console ports to other companies anyway).</p>  <p>&#160;</p>  <h4>Working with the SchemeRegistry</h4>  <p>The IO::SchemeRegistry singleton associates URI schemes (those things at the start of an URI, e.g. “file://…”, “http://…”) with Stream classes. You can override the pre-defined scheme associations or register your own scheme with a stream class of your own:</p>  <blockquote><font face="Courier New">     <p>       <br />// register my own scheme and stream class:         <br />SchemeRegistry::Instance()-&gt;RegisterUriScheme(“myscheme”, MyStream::RTTI);</p>      <p>// create a stream object by URI:        <br />Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“myscheme://bla/blub”);</p>      <p>// the returned stream object should be an instance of our derived class:        <br />n_assert(stream-&gt;IsInstanceOf(MyStream::RTTI));</p>   </font>    <p><font face="Verdana">You can also override standard associations to route all file accesses through your own stream class like this:</font></p>    <blockquote>     <p>// override the file scheme to use our own stream class:        <br />SchemeRegistry::Instance()-&gt;RegisterUriScheme(“file”, MyStream::RTTI);</p>   </blockquote>    <h4></h4> </blockquote>  <h4>&#160;</h4>  <h4><strong><font color="#aa0033" size="3">Reading and writing XML files</font></strong></h4>  <p>Attach an IO::XmlReader object to an IO::Stream object to parse the content of an XML file. The XmlReader can access nodes through path names, so you can navigate XML nodes like files in a file system. The XmlReader tracks a “current node” internally, like the “current directory” in a file system API.</p>  <blockquote><font face="Courier New">     <p>// create an XML reader and parse the file “home:test.xml”:        <br />Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“home:test.xml”);         <br />Ptr&lt;XmlReader&gt; xmlReader = XmlReader::Create();         <br />xmlReader-&gt;SetStream(stream);         <br />if (xmlReader-&gt;Open())         <br />{         <br />&#160;&#160;&#160; // test if a specific node exists in the XML file:         <br />&#160;&#160;&#160; if (xmlReader-&gt;HasNode(“/Nebula3/Models”))…</p>      <p>&#160;&#160;&#160; // position the current node on “/Nebula3/Models”:        <br />&#160;&#160;&#160; xmlReader-&gt;SetToNode(“/Nebula3/Models”);</p>      <p>&#160;&#160;&#160; // iterate over child nodes of current node:        <br />&#160;&#160;&#160; if (xmlReader-&gt;SetToFirstChild()) do         <br />&#160;&#160;&#160; {         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; …         <br />&#160;&#160;&#160; } while (xmlReader-&gt;SetToNextChild());</p>      <p>&#160;&#160;&#160; // iterate over child nodes named “Model”:        <br />&#160;&#160;&#160; if (xmlReader-&gt;SetToFirstChild(“Model”)) do         <br />&#160;&#160;&#160; {         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; …         <br />&#160;&#160;&#160; } while (xmlReader-&gt;SetToNextChild(“Model”));</p>      <p>&#160;&#160;&#160; // test if the current node has a “name” attribute        <br />&#160;&#160;&#160; // and read its value as a string:         <br />&#160;&#160;&#160; if (xmlReader-&gt;HasAttr(“name”))         <br />&#160;&#160;&#160; {         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; String name = xmlReader-&gt;GetString(“name”);         <br />&#160;&#160;&#160; }         <br />        <br />&#160;&#160;&#160; // if the “name” is optional, you can also do this in one line of         <br />&#160;&#160;&#160; // code and provide a default value, if “name” is not present:         <br />&#160;&#160;&#160; String name = xmlReader-&gt;GetOptString(“name”, “DefaultName”);</p>      <p>&#160;&#160;&#160; // you can also read simple data types directly:        <br />&#160;&#160;&#160; int intVal = xmlReader-&gt;GetInt(“intAttr”);         <br />&#160;&#160;&#160; float floatVal = xmlReader-&gt;GetFloat(“floatAttr”);         <br />&#160;&#160;&#160; …</p>      <p>&#160;&#160;&#160; // to read the current node’s content (&lt;Node&gt;Content&lt;/Node&gt;):        <br />&#160;&#160;&#160; if (xmlReader-&gt;HasContent())         <br />&#160;&#160;&#160; {         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; String content = xmlReader-&gt;GetContent();         <br />&#160;&#160;&#160; }</p>      <p>&#160;</p>   </font>    <p><font face="Verdana">To create a new XML file, use an XmlWriter in a similar fashion:</font></p>    <blockquote>     <p><font face="Courier New">Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“temp:bla.xml”);          <br />Ptr&lt;XmlWriter&gt; xmlWriter = XmlWriter::Create();           <br />xmlWriter-&gt;SetStream(stream);           <br />if (xmlWriter-&gt;Open())           <br />{           <br />&#160;&#160;&#160; // write a node hierarchy, and add a few attributes to the leaf node:           <br />&#160;&#160;&#160; xmlWriter-&gt;BeginNode(“Nebula3”);           <br />&#160;&#160;&#160;&#160;&#160; xmlWriter-&gt;BeginNode(“Models”);           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; xmlWriter-&gt;BeginNode(“Model”);           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; xmlWriter-&gt;SetString(“name”, “A Model”);           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; xmlWriter-&gt;SetInt(“intVal”, 20);           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; …           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; xmlWriter-&gt;EndNode();           <br />&#160;&#160;&#160;&#160;&#160; xmlWriter-&gt;EndNode();           <br />&#160;&#160;&#160; xmlWriter-&gt;EndNode();           <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; // close xml writer, this will also close the stream object           <br />&#160;&#160;&#160; xmlWriter-&gt;Close();           <br />}           <br />          <br />// you can also write a comment to the XML file:           <br />xmlWriter-&gt;WriteComment(“A Comment”);           <br />          <br />// or write the content enclosed by the current node:           <br />xmlWriter-&gt;WriteContent(“Content”);</font>         <br />        <br /></p>   </blockquote>    <p><font face="Verdana">Additional notes on XML processing:</font></p>    <ul>     <li><font face="Verdana">XmlReader and XmlWriter use TinyXml internally which has a tiny modification to read and write data through Nebula3 stream objects instead of the host filesystem</font> </li>      <li><font face="Verdana">Reading large XML files can be very slow because of the thousands of small allocations going on for string data, thus reading XML files is not recommended for actual game applications, use optimized binary formats, or Nebula3’s database subsystem instead.</font> </li>      <li><font face="Verdana">There’s currently no easy way to read an XML file, modify it and write it back.</font> </li>   </ul>    <h4><font face="Courier New"></font></h4>    <h4><font face="Verdana"></font></h4>    <h4><font face="Verdana">Working with BinaryReader / BinaryWriter</font></h4>    <p><font face="Verdana">The IO::BinaryReader and IO::BinaryWriter classes implement access to streams as a sequence of simple typed data elements like int, float, float4 or strings with automatic byte order conversion for different platforms:</font></p>    <blockquote>     <p><font face="Courier New">// read data from a file using BinaryReader:          <br />Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“home:bla.bin”);           <br />Ptr&lt;BinaryReader&gt; reader = BinaryReader::Create();           <br />reader-&gt;SetStream(stream);           <br />if (reader-&gt;Open())           <br />{           <br />&#160;&#160;&#160; uchar ucharVal = binaryReader-&gt;ReadUChar();           <br />&#160;&#160;&#160; float floatVal = binaryReader-&gt;ReadFloat();           <br />&#160;&#160;&#160; String strVal&#160; = binaryReader-&gt;ReadString();           <br />&#160;&#160;&#160; Math::matrix44 matrixVal = binaryReader-&gt;ReadMatrix44();           <br />&#160;&#160;&#160; Blob blob = binaryReader-&gt;ReadBlob();           <br />&#160;&#160;&#160; …           <br />&#160;&#160;&#160; reader-&gt;Close();           <br />}           <br />          <br />// writing data is just the other way around:           <br />Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“temp:bla.bin”);           <br />Ptr&lt;BinaryWriter&gt; writer = BinaryWriter::Create();           <br />writer-&gt;SetStream(stream);           <br />if (writer-&gt;Open())           <br />{           <br />&#160;&#160;&#160; writer-&gt;WriteUShort(123);           <br />&#160;&#160;&#160; writer-&gt;WriteString(“Bla”);           <br />&#160;&#160;&#160; …           <br />&#160;&#160;&#160; writer-&gt;Close();           <br />}</font></p>   </blockquote>    <p><font face="Verdana">The byte order of BinaryReader/Writer is by default set to ByteOrder::Host (the host platform’s native byte order). You can enable automatic byte order conversion with the SetStreamByteOrder() method on BinaryReader and BinaryWriter. For instance, to create a binary file for one of the PowerPC-driven consoles from a tool running on the PC you would setup the BinaryWriter like this:</font></p>    <blockquote>     <p><font face="Courier New">Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“temp:bla.bin”);          <br />Ptr&lt;BinaryWriter&gt; writer = BinaryWriter::Create();           <br />writer-&gt;SetStream(stream);           <br />writer-&gt;SetStreamByteOrder(System::ByteOrder::BigEndian);           <br />if (writer-&gt;Open()) …</font>         <br /></p>   </blockquote>    <p><font face="Verdana">Automatic byte order conversion naturally doesn’t work for Util::Blob objects, since the reader/writer doesn’t know how the data inside the blob is structured.</font></p>    <p><font face="Verdana">Additional Notes:</font></p>    <ul>     <li><font face="Verdana">Only use BinaryReader / BinaryWriter in an actual game project when absolutely necessary. For the sake of efficient and fast loading from disk it’s usually better to prepare any sort of game data as a native memory dump which can be loaded with a simple Stream::Read() and immediately used without any parsing or data conversions going on during load. Time spent in the build pipeline is a thousand times cheaper then time spent waiting for a level to load, thus BinaryReader and BinaryWriter are much better used in offline tools!</font> </li>      <li><font face="Verdana">Even in offline tools, BinaryReader/Writer can be very slow when processing thousands of data elements, since reading or writing each little data element will cause a complete round-trip through the ReadFile / WriteFile functions of the host’s operating system. Use the <strong>SetMemoryMappingEnabled(true)</strong> method to speed up reading and writing of data elements drastically by caching the data in memory. In the BinaryReader, this will load the entire file into memory in Open(), and in the BinaryWriter, all writes will go into a memory buffer first, which will then be dumped to a file in Close() with a single Write().</font> </li>   </ul>    <p>&#160;</p>    <h4><font face="Verdana">Reading Excel XML files with Nebula3</font></h4>    <p><font face="Verdana">You can use the IO::ExcelXmlReader stream reader class to parse files saved in XML format from MS Excel (all versions should work, but when in doubt, save as Excel 2003 XML file). After opening an Excel file, the content of the file can be accessed by table, column and row index:</font></p>    <blockquote>     <p><font face="Courier New">Ptr&lt;Stream&gt; stream = IoServer::Instance()-&gt;CreateStream(“home:excelsheet.xml”);          <br />Ptr&lt;ExcelXmlReader&gt; reader = ExcelXmlReader::Create();           <br />reader-&gt;SetStream(stream);           <br />if (reader-&gt;Open())           <br />{           <br />&#160;&#160;&#160; // NOTE: when working with the left-most “default” table,           <br />&#160;&#160;&#160; // we can simply omit the table index in all methods.           <br />&#160;&#160;&#160; //&#160; <br />&#160;&#160;&#160; // Test if a column exists in the left-most table:           <br />&#160;&#160;&#160; if (xmlReader-&gt;HasColumn(“Bla”))           <br />&#160;&#160;&#160; {           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // get the column index (returns InvalidIndex if not exists)           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IndexT colIndex = xmlReader-&gt;FindColumnIndex(“Bla”);           <br />          <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // iterate over all rows and read content of column “Bla”:           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IndexT rowIndex;           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; SizeT numRows = xmlReader-&gt;GetNumRows();           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (rowIndex = 0; rowIndex &lt; numRows; rowIndex++)           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // get the content of cell at (rowIndex,colIndex):           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; String elm = xmlReader-&gt;GetElement(rowIndex, colIndex);           <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }           <br />&#160;&#160;&#160; }           <br />}</font></p>   </blockquote>    <p><font face="Verdana">You can also access specific tables in an Excel file. In this case, an additional tableIndex parameter is used in most methods:</font></p>    <blockquote>     <p><font face="Courier New">// get the number of tables in the Excel file:          <br />SizeT numTables = xmlReader-&gt;GetNumTables();</font></p>      <p><font face="Courier New">// find a table index by name (return InvalidIndex if not exists)          <br />IndexT tableIndex = xmlReader-&gt;GetTableIndex(“TableName”);</font></p>     <font face="Courier New">// get the name of table at index        <br />const String&amp; tableName = xmlReader-&gt;GetTableName(tableIndex); </font>      <p><font face="Courier New">// to access a particular table, simply add the table index as last          <br />// parameter to all other methods:           <br />SizeT numRowsOfTable = xmlReader-&gt;GetNumRows(tableIndex);           <br />SizeT numColsOfTable = xmlReader-&gt;GetNumColumns(tableIndex);           <br />bool hasColumn = xmlReader-&gt;HasColumn(“Bla”, tableIndex);           <br />String elm = xmlReader-&gt;GetElement(rowIndex, colIndex, tableIndex);           <br />…</font></p>   </blockquote>    <p>Note that Excel XML files come with a lot more fluff then actual data, so reading an Excel table bigger then a few dozen or hundred kBytes is EXTREMELY slow. Do not use Excel XML files directly in your game application, but only as source data files in the content pipeline, and convert them to binary files or write them into an SQLite database during the build process for more efficient consumption by the game application.</p>    <h4>&#160;</h4>    <h4>How to register you own ConsoleHandler</h4>    <p>Console handlers are attached to the IO::Console singleton to handle console output and optionally provide text input from a console. When Nebula3 starts up, a standard console handler is created in IO::Console::Open() which (under Windows) will route output to STD_OUTPUT_HANDLE and STD_ERROR_HANDLE, and provide non-blocking input from STD_INPUT_HANDLE. When not compiled with the PUBLIC_BUILD define, all text output will also go to OutputDebugString() and thus show up in the debugger, which is especially useful when running a windowed application (as opposed to a console application) under Windows.</p>    <p>On console platforms, the default ConsoleHandlers route all text output to the debug out channel.</p>    <p>Nebula3 provides 2 optional console handlers:</p>    <ul>     <li><strong>IO::LogFileConsoleHandler: </strong>can be used to capture all text output into a log file </li>      <li><strong>IO::HistoryConsoleHander:</strong> captures console output into an in-memory ring buffer, this is currently used by the IO::ConsolePageHandler for the Debug-HTTP-Server in order to provide a snapshot of console output in a web browser connected to the N3 application. </li>   </ul>    <p>Registering your own console handler is easy: just derive a subclass from IO::ConsoleHandler, override a few virtual methods, and call IO::Console::AttachHandler() with a pointer to an instance of your derived class early in your application.</p>    <p>&#160;</p> </blockquote>  <p></p>  <p>Phew, I think that’s all the stuff that’s good-to-know when doing file IO in Nebula3. Please note that this was all about synchronous I/O. For asynchronous IO the IO::IoInterface interface-singleton is used, this simply launches a thread with its own thread-local IoServer, and IO operations are sent to the IO thread using Message objects (which in turn need to be checked for completion of the IO operation). It’s not much more complicated then synchronous IO. However I’m planning to do a few changes under the hood for asynchronous IO to enable better platform-specific optimizations in the future.</p>  