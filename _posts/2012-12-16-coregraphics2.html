---
layout: post
title: CoreGraphics2
date: '2012-12-16T18:06:00.000+01:00'
author: Andre Weissflog
tags: 
modified_time: '2012-12-16T18:52:30.977+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-3730166492975753899
blogger_orig_url: http://flohofwoe.blogspot.com/2012/12/coregraphics2.html
---

That's Twiggy's official name now.<br /><br />I've basically written a vertical slice of the new Nebula3 Render Layer during the past few weekends where I'm trying out a few ideas of what the Nebula3 rendering system will look like in the future.<br /><br />The lowest-level subsystem is <b>CoreGraphics2</b>, which I wrote about already a little bit.<br /><br />It wraps the host platform's 3D API (e.g. OpenGL or Direct3D), the rendering vocabulary is higher level / less verbose then OpenGL/D3D. It runs the render thread, but can be compiled without threading (on the emscripten platform for instance). There's a facade singleton object (CoreGraphics2Facade) which wraps the entire functionality into a surprisingly simple interface.<br /><div><br /></div><div>CoreGraphics2 works with only 5 resource types:</div><div><ol><li><i style="font-weight: bold;">Texture:</i>&nbsp;Just what the name implies, a texture resource object. This also includes render targets.</li><li><i style="font-weight: bold;">Mesh:</i>&nbsp;This encapsulates all the required geometry data for a drawing operation: vertex buffer, index buffer (optional), vertex layout / vertex array definition, and "primitive groups" (basically sub-mesh definitions).&nbsp;</li><li><i style="font-weight: bold;">DrawState:</i>&nbsp;This wraps all the required shader and render-state data for a drawing operation: a reference to a shader object, shader constants (one-time-init, immutable), shader variables (mutable) and an (immutable) state-block for render-states.</li><li><i style="font-weight: bold;">Pass:</i>&nbsp;A pass object holds all required data for a rendering pass, this includes a render-target-texture object, and a DrawState object which defines state which is valid for the rendering pass. All rendering must happen inside passes. Typical passes in a pre-light-pass renderer are for instance the NormalDepth-Pass, the Light-Pass, the Material-Pass, and a Compose-Pass. The pass object also contains the information whether and how the render target should be cleared at the start of the pass.</li><li><i style="font-weight: bold;">Batch:</i>&nbsp;A batch object just contains a DrawState object which defines render state for several draw operations, so this is just a way to reduce redundant state switches.</li></ol><div>Resource objects are opaque to the outside. To the caller, these are just ResourceId objects, there's no way to directly access the data in the resource objects (since they actually live in the render thread).</div></div><div><br /></div><div>Resource creation happens by passing a Setup object to one of the Create methods in the CoreGraphics2Facade singleton. There's one Setup class for each resource type (so basically TextureSetup, MeshSetup, DrawStateSetup, PassSetup and BatchSetup). The Setup object basically describes how the resource should be created and shared (for instance when creating a texture resource, the Setup object would contain the path to the texture file, whether the texture should be loaded asynchronously, whether the texture object should be a render target, and so on). The render thread will keep the Setup objects around, so it has all information available to re-create the resource (for instance because of D3D's lost device state, or for more advanced resource management where currently unused resources can be removed from memory, and re-loaded later).</div><div><br /></div><div>All rendering happens by calling methods of CoreGraphics2Facade:</div><div><br /></div><div><b>Begin / End methods:</b></div><div>These methods structure a frame into segments.&nbsp;</div><div><ul><li><i>BeginFrame / EndFrame:</i> Signal the start and end of a render frame.&nbsp;</li><li><i>BeginPass / EndPass:</i> Signal start and end of a rendering pass. BeginPass takes the ResourceId of a Pass object, makes the render target of the pass active, optionally clears the render target, and applies the render state of the DrawState object of the pass.</li><li><i>BeginBatch / EndBatch:</i> Signal start and end of a rendering batch. This simply applies the render state of the DrawState object of the batch.</li><li><i>BeginInstances / EndInstances:</i>&nbsp;This is where it gets interesting. BeginInstances sets all the required state for a series of Draw commands. It takes a Mesh ResourceId, a DrawState ResourceId, and a "shader variation bitmask". The bitmask basically selects a "technique" from the shader (in D3DXEffects terms). For instance, to select the right shader technique for rendering the NormalDepth-pass of a skinned object, one would pass "NormalDepth|Skinning" as the bitmask.</li></ul><div><b>Apply methods:</b></div></div><div>This method group applies dynamic state changes during a frame:</div><div><ul><li><i>ApplyProjectionTransform, ApplyViewTransform, ApplyModelTransform: </i>Sets the projection, view and model matrices.</li><li><i>ApplyVariable: </i>applies a shader variable value to the currently active DrawState object (which has been set during BeginInstances). This is a template method, specialized for each shader variable data type (float, int, float4, matrix44, bool).</li><li><i>ApplyVariableArray:</i>&nbsp;same as ApplyVariable, but for an array of values.</li></ul></div><div><b>Draw methods:</b></div><div>This method group performs actual drawing operations:</div><div><ul><li><i>Draw:</i>&nbsp;Performs a single draw call, must be called inside BeginInstances/EndInstances. Renders a PrimitiveGroup (aka material group) from the currently active Mesh, using the render state defined in the currently active DrawState. For non-instanced rendering one would usually perform several ApplyModelTransform() / Draw() pairs in a row.</li><li><i>DrawInstanced:</i>&nbsp;Like Draw, but takes an array of per-instance transforms to render the same mesh at many different positions. Tries to use some sort of hardware instancing, but falls back to a "tight render loop" if no hardware instancing is available.</li><li><i>DrawFullscreenQuad:</i>&nbsp;simply render a fullscreen quad with the currently set DrawState, this is used for fullscreen-post-effects</li></ul><div>And that's it basically. I'm quite happy with how simple everything looks from the outside, and how straight-forward the innards work. For instance, leaving the shader system aside (which is implemented in a separate subsystem CoreShader), the OpenGL specific code in CoreGraphics2 is just 7 classes, and the biggest file is around 600 lines of code.</div></div><div><br /></div><div>And it's simple to use, for instance here's the render loop to render the point lights in the new LightPrePassRenderer (hopefully the Blogger editor won't screw up my formatting):</div><blockquote class="tr_bq"><div class="p1"><span class="s1">&nbsp; &nbsp;&nbsp;</span><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">CoreGraphics2Facade<span class="s1">* cg2Facade = </span>CoreGraphics2Facade<span class="s1">::</span><span class="s2">Instance</span><span class="s1">();</span></span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; <span class="s3">if</span> (<span class="s3">this</span>-&gt;<span class="s2">pointLights</span>.<span class="s2">Size</span>() &gt; <span class="s3">0</span>)</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; {</span></div><div class="p3"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;"><span class="s1">&nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;</span>BeginInstances<span class="s1">(</span><span class="s3">this</span><span class="s1">-&gt;</span>pointLightMesh<span class="s1">, </span><span class="s3">this</span><span class="s1">-&gt;</span>lightDrawState<span class="s1">, </span><span class="s3">this</span><span class="s1">-&gt;</span>pointLightFeatureBits<span class="s1">, </span><span class="s3">false</span><span class="s1">);</span></span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; <span class="s4">IndexT</span> i;</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; <span class="s3">for</span> (i = <span class="s3">0</span>; i &lt; <span class="s3">this</span>-&gt;<span class="s2">pointLights</span>.<span class="s2">Size</span>(); i++)</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; {</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="s3">const</span> <span class="s4">Light</span>* curLight = <span class="s3">this</span>-&gt;<span class="s2">pointLights</span>[<span class="s2">i</span>];</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="s3">const</span> <span class="s4">matrix44</span>&amp; lightTransform = curLight-&gt;<span class="s2">GetTransform</span>();</span></div><div class="p4"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></div><div class="p5"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;"><span class="s1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span>// compute light position in view space, and set .w to inverted light range</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="s4">float4</span> posAndRange = <span class="s4">matrix44</span>::<span class="s2">transform</span>(lightTransform.<span class="s2">get_position</span>(), <span class="s3">this</span>-&gt;<span class="s2">viewTransform</span>);</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; posAndRange.<span class="s2">w</span>() = <span class="s3">1.0f</span> / lightTransform.<span class="s2">get_zaxis</span>().<span class="s2">length</span>();</span></div><div class="p4"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></div><div class="p5"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;"><span class="s1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span>// update shader params</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;<span class="s2">ApplyModelTransform</span>(lightTransform);</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;<span class="s2">ApplyVariable</span>&lt;<span class="s4">float4</span>&gt;(<span class="s2">LightPosRange</span>, posAndRange);</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;<span class="s2">ApplyVariable</span>&lt;<span class="s4">float4</span>&gt;(<span class="s2">LightColor</span>, curLight-&gt;<span class="s2">GetColor</span>());</span></div><div class="p3"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;"><span class="s1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;</span>ApplyVariable<span class="s1">&lt;</span><span class="s3">float</span><span class="s1">&gt;(</span>LightSpecularIntensity<span class="s1">, curLight-&gt;</span>GetSpecularIntensity<span class="s1">());</span></span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;<span class="s2">Draw</span>(<span class="s3">0</span>);</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; &nbsp; &nbsp; cg2Facade-&gt;<span class="s2">EndInstances</span>();</span></div><div class="p2"><span style="font-family: Courier New, Courier, monospace; font-size: xx-small;">&nbsp; &nbsp; }</span></div></blockquote><div>The only thing that's still missing from CoreGraphics2 is dynamic resources and a plugin system to extend functionality of the render-thread side with custom code (for instance for non-essential stuff like runtime resource baking).&nbsp;</div><div><br /></div><div>As much as I'd love to have a rendering system where dynamic resources aren't needed at all, there's no way around them yet. We still need them for particle systems and UI rendering.</div><div><br /></div><div>On the front-end of the render layer, there's the new <b>Graphics2</b>&nbsp;subsystem. The changes are not as radical as in CoreGraphics2 (with good reason because changes in this subsystem would affect a lot of high level gameplay code). There are still the basic object types <b>Stage</b>, <b>View</b>, <b>Camera</b>, <b>Light</b> and <b>Model</b>. There's now a new <b>GraphicsFacade</b> object, which simplifies setup and manipulation of the graphics world drastically. And I tried out a new component-system for GraphicsEntities (Models, Lights and Cameras). Instead of a inheritance hierarchy for the various GraphicsEntity types, there's now only one GraphicsEntity class which owns a set of Component objects. The combination of those components is what turns a GraphicsEntity into a visible 3D model, a light source, or a camera. The main driver behind this was that 90% of all data in a ModelEntity was character related, but less then 10% of graphics objects in a typical graphics world are actually characters.</div><div><br /></div><div>I've split the existing functionality into the following entity components:</div><div><ul><li><b>TransformComponent:</b>&nbsp;defines the entity's position and bounding box volume in world space.</li><li><b>TimingComponent:</b>&nbsp;keeps track of the entity-local time</li><li><b>VisibilityComponent:</b>&nbsp;attached the entity to the Visibility subsystem (view frustum culling)</li><li><b>ModelComponent:</b>&nbsp;renders the entity as a simple 3D object</li><li><b>CharacterComponent:</b>&nbsp;additional functionality for skinned characters (animations, skins, joint attachments, ...)</li><li><b>LightComponent:</b>&nbsp;turns the entity into a light source</li><li><b>CameraComponent:</b>&nbsp;turns the entity into a camera</li></ul><div>This component model hasn't really been written to allow strange combinations (you might be tempted to attach a CameraComponent to a Character-entity for a first person shooter). Theoretically something like this might be even possible, but I don't think it is a good idea. The driving force behind the component model was cleaner code and better memory usage.</div></div><div><br /></div>