---
layout: post
title: cmake and the Android NDK
date: '2014-04-20T19:51:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2014-04-20T22:28:13.965+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-6708919744758805744
blogger_orig_url: http://flohofwoe.blogspot.com/2014/04/cmake-and-android-ndk.html
---

<p>TL;DR: how to build Android NDK applications with cmake instead of the custom NDK build system, this is useful for projects which already use cmake to create multiplatform/cross-compiling build files.</p> <p><strong>Update:</strong> Thanks to <a href="thp.io">thp</a> for pointing out a rather serious bug: packaging the standard shared libraries into the APK should NOT be necessary since these are pre-installed on the device. I noticed that I didn’t set a library search path to the toolchain lib dir in the linker step (-L…) which might explain the crash I had earlier, but unfortunately I can’t reproduce this crash anymore with the old behaviour (no library search path and no shared system libraries in the APK). I’ll keep an eye on that and update the blog post with my findings.</p> <hr> <p>I’ve spent the last 2.5 days adding Android support to Oryol’s build system. This wasn’t exactly on my to-do list until I sorta “impulse-bought” a Nexus7 tablet last Thursday. It basically went like this “hey that looks quite neat for a non-iPad tablet =&gt; wow, scrolling feels smooth, very non-Android-like =&gt; holy shit it runs my Oryol WebGL samples at 60fps =&gt; hmm 179 Euros seems quite reasonable…” - I must say I’m impressed how far the Android “user experience” has come since I last dabbled with it. The UI finally feels completely smooth, and I didn’t have any of those Windows8-Metro-style WTF-moments yet.</p> <p>Ok, so the logical next step would be to add support for Android to the Oryol build system (if you don’t know what Oryol is: it’s a new experimental C++11 multi-plat engine I started a couple months ago: <a href="https://github.com/floooh/oryol">https://github.com/floooh/oryol</a>).</p> <p>The Oryol build system is cmake-based, with a python script on top which simplifies managing the dozens of possible build-configs. A build-config is one specific combination of target-platform (osx, ios, win32, win64, …), build-tools (make, ninja, Visual Studio, Xcode, …) and compile-mode (Release, Debug) stored under a descriptive name (e.g. osx-xcode-debug, win32-vstudio-release, emscripten-make-debug, …).</p> <p>The front-end python script called ‘oryol’ is used to juggle all the build-configs, invoke cmake with the right options, and perform command line builds.</p> <p>One can for instance simply call:</p><div class="se-section-delimiter"></div> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol update osx</span><span class="pun">-</span><span class="pln">xcode</span><span class="pun">-</span><span class="pln">debug</span></code></pre> <p>…to generate an Xcode project.</p> <p>Or to perform a command line build with xcodebuild instead:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol build osx</span><span class="pun">-</span><span class="pln">xcode</span><span class="pun">-</span><span class="pln">debug</span></code></pre> <p>Or to build Oryol for emscripten with make in Release mode (provided the emscripten SDK has been installed):</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol build emscripten</span><span class="pun">-</span><span class="pln">make</span><span class="pun">-</span><span class="pln">release</span></code></pre> <p>This also works on Windows (32- or 64-bit): </p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> oryol build win64</span><span class="pun">-</span><span class="pln">vstudio</span><span class="pun">-</span><span class="pln">debug<br /></span><span class="pun">&gt;</span><span class="pln"> oryol build win32</span><span class="pun">-</span><span class="pln">vstudio</span><span class="pun">-</span><span class="pln">debug</span></code></pre> <p>…or on Linux:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol build linux</span><span class="pun">-</span><span class="pln">make</span><span class="pun">-</span><span class="pln">debug</span></code></pre> <p>Now, what I want to do with my shiny new Nexus7 is of course this:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol build android</span><span class="pun">-</span><span class="pln">make</span><span class="pun">-</span><span class="pln">debug</span></code></pre> <p>This turned out to be harder then usual. But lets start at the beginning:</p> <p>A cross-compiling scenario is normally well defined in the GCC/cmake world:</p> <p>A <strong>toolchain</strong> wraps the target-platform’s compiler tools, system headers and libs under a standardized directory structure:</p> <p>The compiler tools usually reside in a <strong>bin</strong> subdirectory, and are called <strong>gcc</strong> and <strong>g++</strong>, or in the LLVM world: <strong>clang</strong> and <strong>clang++</strong>, sometimes the tools also have a prefix: <strong>pnacl-clang</strong> and <strong>pnacl-clang++</strong>), or they have completely different names (like <strong>emcc</strong> in the emscripten SDK).</p> <p>Headers and libs are often located in a <strong>usr</strong> directory (<strong>usr/include</strong> and <strong>usr/lib</strong>).</p> <p>The toolchain headers contain at least the the C-Runtime headers, like <strong>stdlib.h</strong>, <strong>stdio.h</strong> and usually the C++ headers (<strong>vector</strong>, <strong>iostream</strong>, …) and often also the OpenGL headers and other platform-specific header files.</p> <p>Finally the lib directory contains precompiled system libraries for the target platform (for instance <strong>libc.a</strong>, <strong>libc++.a</strong>, etc…).</p> <p>With such a standard gcc-style toolchain, cross-compilation is very simple. Just make sure that the toolchain-compiler tools are called instead of the host platform’s tools, and that the toolchain headers and libs are used.</p> <p>cmake standardizes this process with its so-called <strong>toolchain-files</strong>. A toolchain-file defines what compilers tools, headers and libraries should be used instead of the ‘default’ ones, and usually also overrides compile and linker flags.</p> <p>The typical strategy when adding a new target platform to a cmake build system looks like this:</p> <ul><li>setup the target platform’s SDK </li><li>create a new toolchain file (obviously)</li><li>tell cmake where to find the compiler tools, header and libs</li><li>add the right compile and linker flags</li></ul> <p>Once the toolchain file has been created, call cmake with the toolchain file:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> cmake </span><span class="pun">-</span><span class="pln">G</span><span class="str">"Unix Makefiles"</span><span class="pln"> </span><span class="pun">-</span><span class="pln">DCMAKE_TOOLCHAIN_FILE</span><span class="pun">=[</span><span class="pln">path</span><span class="pun">-</span><span class="pln">to</span><span class="pun">-</span><span class="pln">toolchain</span><span class="pun">-</span><span class="pln">file</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[</span><span class="pln">path</span><span class="pun">-</span><span class="pln">to</span><span class="pun">-</span><span class="pln">project</span><span class="pun">]</span></code></pre> <p>Then run make in verbose mode to check whether the right compiler is called, and with the right options:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> make VERBOSE</span><span class="pun">=</span><span class="lit">1</span></code></pre> <p>This approach works well for platforms like emscripten or Google Native Client. Some platforms require a bit of additional cmake-magic, a Portable Native Client executable for instance must be “finalized” after it has been linked. Additional build steps like these can be added easily in cmake with the <strong>add_custom_command</strong> macro.</p> <p>Integrating Android as a new target platform isn’t so easy though:</p> <ul><li>the Android SDK itself only allows to create pure Java applications, for C/C++ apps, the separate Android NDK (Native Development Kit) is required</li><li>the NDK doesn’t produce complete Android applications, it needs the Android Java SDK for this</li><li>native Android code isn’t a typical executable, but lives in a shared library which is called from Java through JNI</li><li>the Android SDK and NDK both have their own build systems which hide a lot of complexity</li><li>…this complexity comes from the combination of different host platforms (OSX, Linux, Windows), target API levels (android-3 to android-19, roughly corresponding to Android versions), compiler versions (gcc4.6, gcc4.9, clang3.3, clang3.4), and finally CPU architectures and instruction sets (ARM, MIPS, X86, with several variations for ARM (armv5, armv7, with or without NEON, etc…)</li><li>C++ support is still bolted on, the C++ headers and libs are not in their standard locations</li><li>the NDK doesn’t follow the standard GCC toolchain directory structure at all</li></ul> <p>The custom build system coming with the NDK does a good job to hide all this complexity, for instance it can automatically build for all CPU architectures, but it stops after the native shared library has been compiled: it cannot create a complete Android APK. For this, the Android Java SDK tools must be called from the command line.</p> <p>So back to how to make this work in cmake:</p> <p>The plan looks simple enough:</p> <ol><li>compile our C/C++ code into a shared library instead of an executable</li><li>somehow get this into a Java APK package file…</li><li>…deploy APK to Android device and run it</li></ol> <p>Step 1 starts rather innocent, create a toolchain file, look up the paths to the compiler tools, headers and libs in the NDK, then lookup the compiler and linker command line args by watching a verbose build. Then put all this stuff into the right cmake variables. At least this is how it usually works. Of course for Android it’s all a bit more complicated:</p> <ul><li>first we need to decide on a target CPU architecture and what compiler to use. I settled for ARM and gcc4.8, which leads us to <strong>[…]/android-ndk-r9d/toolchains/arm-linux-androideabi-4.8/prebuilt</strong></li><li>in there is a directory <strong>darwin-x86_64</strong> so we need separate paths by host platform here</li><li>finally in there is a bin directory with the compiler tools, so GCC would be for instance at <strong>[..]/android-ndk-r9d/toolchains/arm-linux-androideabi-4.8/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-gcc</strong></li><li>there’s also an include, lib and share directory but the stuff in there definitely doesn’t look like system headers and libs… bummer.</li><li>the system headers and libs are under the platforms directory instead: <strong>[..]/android-ndk-r9d/platforms/android-19/arch-arm/usr/include</strong>, and <strong>[..]/android-ndk-r9d/platforms/android-19/arch-arm/usr/lib</strong></li><li>so far so good… put this stuff into the toolchain file and it seems to compile fine – until the first C++ header must be included - WTF?</li><li>on closer inspection, the system include directory doesn’t contain any C++ headers, and there’s different C++ lib implementations to choose from under <strong>[..]/android-ndk-r9d/sources/cxx-stl</strong></li></ul> <p>This was the point where was seriously thinking about calling it a day until I stumbled across the <strong>make-standalone-toolchain.sh</strong> in build/tools. This is a helper script which will build a standard GCC-style toolchain for one specific Android API-level and target CPU:</p> <pre class="prettyprint prettyprinted"><code><span class="pln">sh make</span><span class="pun">-</span><span class="pln">standalone</span><span class="pun">-</span><span class="pln">toolchain</span><span class="pun">.</span><span class="pln">sh </span><span class="pun">–-</span><span class="pln">platform</span><span class="pun">=</span><span class="pln">android</span><span class="pun">-</span><span class="lit">19</span><span class="pln"> <br />  </span><span class="pun">–-</span><span class="pln">ndk</span><span class="pun">-</span><span class="pln">dir</span><span class="pun">=</span><span class="str">/Users/</span><span class="pun">[</span><span class="pln">user</span><span class="pun">]/</span><span class="pln">android</span><span class="pun">-</span><span class="pln">ndk</span><span class="pun">-</span><span class="pln">r9d<br />  </span><span class="pun">–-</span><span class="pln">install</span><span class="pun">-</span><span class="pln">dir</span><span class="pun">=</span><span class="str">/Users/</span><span class="pun">[</span><span class="pln">user</span><span class="pun">]/</span><span class="pln">android</span><span class="pun">-</span><span class="pln">toolchain <br />  </span><span class="pun">–-</span><span class="pln">toolchain</span><span class="pun">=</span><span class="pln">arm</span><span class="pun">-</span><span class="pln">linux</span><span class="pun">-</span><span class="pln">androideabi</span><span class="pun">-</span><span class="lit">4.8</span><span class="pln"><br />  </span><span class="pun">--</span><span class="pln">system</span><span class="pun">=</span><span class="pln">darwin</span><span class="pun">-</span><span class="pln">x86_64</span></code></pre> <p>This will extract the right tools, headers and libs, and also integrate C++ headers (by default gnustl, but can be selected with the –stl option). When the script is done, a new directory ‘android-toolchain’ has been created which follows the GCC toolchain standard, and is much easier to integrate with cmake: </p> <p>The important directories are: <br>- <strong>[..]/android-toolchain/bin</strong>, this is where the compiler tools are located, these are still prefixed though (e.g. <strong>arm-linux-androideabi-gcc</strong> <br>- <strong>[..]/android-toolchain/sysroot/usr/include</strong> CRT headers, plus EGL, GLES2, etc…, but NOT the C++ headers <br>- <strong>[..]/android-toolchain/include</strong> the C++ headers are here, under ‘c++’ <br>- <strong>[..]/android-toolchain/sysroot/usr/lib</strong> .a and .so system libs, libstc++.a/.so is also here, no idea why</p> <p>After setting these paths in the toolchain file, and telling cmake to create shared-libs instead of exes when building for the Android platform I got the compiler and linker steps. Instead of a CoreHello executable, I got a libCoreHello.so. So far so good.</p> <p>Next step was to figure out how to get this .so into a APK which can be uploaded to an Android device.</p> <p>The NDK doesn’t help with this, so this is where we need the Java SDK tools, which uses yet another build system: ant. From looking at the SDK samples I figured out that it is usually enough to call <strong>ant debug</strong> or <strong>ant release</strong> within a sample directory to build an .apk file into a bin subdirectory. ant requires a <strong>build.xml</strong> file which defines the build tasks to perform. Furthermore, Android apps have an embedded AndroidManifest.xml file which describes how to run the application, and what privileges it requires. None of these exist in the NDK samples directories though…</p> <p>After some more exploration it became clear: The SDK has a helper script called <strong>android</strong> which is used (among many other things) to setup a project directory structure with all required files for ant to create a working APK:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> android create project<br />    </span><span class="pun">--</span><span class="pln">path </span><span class="typ">MyApp</span><span class="pln"><br />    </span><span class="pun">--</span><span class="pln">target android</span><span class="pun">-</span><span class="lit">19</span><span class="pln"><br />    </span><span class="pun">--</span><span class="pln">name </span><span class="typ">MyApp</span><span class="pln"><br />    </span><span class="pun">--</span><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">oryol</span><span class="pun">.</span><span class="typ">MyApp</span><span class="pln"><br />    </span><span class="pun">--</span><span class="pln">activity </span><span class="typ">MyActivity</span></code></pre> <p>This will setup a directory ‘MyApp’ with a complete Android Java skeleton app. Run ‘ant debug’ in there and it will create a ‘MyApp-debug.apk’ in the ‘bin’ subdirectory which can be deployed to the Android device with ‘adb install MyApp-debug.apk’, which when executed displays a ‘Hello World, MyActivity’ string. </p> <p>Easy enough, but there are 2 problems, <strong>first</strong>: how to get our native shared library packaged and called?, and <strong>second</strong>: the Java SDK project directory hierarchy doesn’t really fit well into the source tree of a C/C++ project. There should be a directory per sample app with a couple of C++ files and a CMakeLists.txt file and nothing more.</p> <p>The first problem is simple to solve: the project directory hierarchy contains a libs directory, all .so files in there will be copied into the APK by ant (to verify this: a .apk is actually a zip file, simply changed the file extension to zip and peek into the file). One important point: the lib directory contains one sub-directory-level for the CPU architecture, so once we start to support multiple CPU instruction sets we need to put them into subdirectories like this:</p> <pre class="prettyprint prettyprinted"><code><span class="typ">FlohOfWoe</span><span class="pun">:</span><span class="pln">libs floh$ ls<br />armeabi     armeabi</span><span class="pun">-</span><span class="pln">v7a mips        x86</span></code></pre> <p>Since my cmake build-system currently only supports building for armeabi-v7a I’ve put my .so file in the armeabi-v7a subdirectory.</p> <p>Now I thought that I had everything in place, I got an APK file with my native code .so lib in it, I used the NativeActivity and the android_native_app_glue.h approach, and logged out a “Hello World” to the system log (which can be inspected with <strong>adb logcat</strong> from the host system).</p> <p>And still the App didn’t start, instead this showed up in the log:</p> <pre class="prettyprint prettyprinted"><code><span class="pln">D</span><span class="pun">/</span><span class="typ">AndroidRuntime</span><span class="pun">(</span><span class="pln">  </span><span class="lit">482</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Shutting</span><span class="pln"> down VM<br />W</span><span class="pun">/</span><span class="pln">dalvikvm</span><span class="pun">(</span><span class="pln">  </span><span class="lit">482</span><span class="pun">):</span><span class="pln"> threadid</span><span class="pun">=</span><span class="lit">1</span><span class="pun">:</span><span class="pln"> thread exiting </span><span class="kwd">with</span><span class="pln"> uncaught exception </span><span class="pun">(</span><span class="kwd">group</span><span class="pun">=</span><span class="lit">0x41597ba8</span><span class="pun">)</span><span class="pln"><br />E</span><span class="pun">/</span><span class="typ">AndroidRuntime</span><span class="pun">(</span><span class="pln">  </span><span class="lit">482</span><span class="pun">):</span><span class="pln"> FATAL EXCEPTION</span><span class="pun">:</span><span class="pln"> main<br />E</span><span class="pun">/</span><span class="typ">AndroidRuntime</span><span class="pun">(</span><span class="pln">  </span><span class="lit">482</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Process</span><span class="pun">:</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">oryol</span><span class="pun">.</span><span class="typ">CoreHello</span><span class="pun">,</span><span class="pln"> PID</span><span class="pun">:</span><span class="pln"> </span><span class="lit">482</span><span class="pln"><br />E</span><span class="pun">/</span><span class="typ">AndroidRuntime</span><span class="pun">(</span><span class="pln">  </span><span class="lit">482</span><span class="pun">):</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">lang</span><span class="pun">.</span><span class="typ">RuntimeException</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Unable</span><span class="pln"> to start activity </span><span class="typ">ComponentInfo</span><span class="pun">{</span><span class="pln">com</span><span class="pun">.</span><span class="pln">oryol</span><span class="pun">.</span><span class="typ">CoreHello</span><span class="pun">/</span><span class="pln">android</span><span class="pun">.</span><span class="pln">app</span><span class="pun">.</span><span class="typ">NativeActivity</span><span class="pun">}:</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">lang</span><span class="pun">.</span><span class="typ">IllegalArgumentException</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Unable</span><span class="pln"> to load </span><span class="kwd">native</span><span class="pln"> library</span><span class="pun">:</span><span class="pln"> </span><span class="str">/data/</span><span class="pln">app</span><span class="pun">-</span><span class="pln">lib</span><span class="pun">/</span><span class="pln">com</span><span class="pun">.</span><span class="pln">oryol</span><span class="pun">.</span><span class="typ">CoreHello</span><span class="pun">-</span><span class="lit">1</span><span class="pun">/</span><span class="pln">libCoreHello</span><span class="pun">.</span><span class="pln">so<br />E</span><span class="pun">/</span><span class="typ">AndroidRuntime</span><span class="pun">(</span><span class="pln">  </span><span class="lit">482</span><span class="pun">):</span><span class="pln">    at android</span><span class="pun">.</span><span class="pln">app</span><span class="pun">.</span><span class="typ">ActivityThread</span><span class="pun">.</span><span class="pln">performLaunchActivity</span><span class="pun">(</span><span class="typ">ActivityThread</span><span class="pun">.</span><span class="pln">java</span><span class="pun">:</span><span class="lit">2195</span><span class="pun">)</span></code></pre> <p>This was the second time where I banged my head against the wall for a while until I started to look into how linker dependencies are resolved for the shared library. I was pretty sure that I gave all the required libs on the linker command line (-lc -llog -landroid, etc), the error was that I assumed that these are linked statically. Instead default linking against system libraries is dynamic. The ndk-depends helps in finding the dependencies:</p> <pre class="prettyprint prettyprinted"><code><span class="pln">localhost</span><span class="pun">:</span><span class="pln">armeabi</span><span class="pun">-</span><span class="pln">v7a floh$ </span><span class="pun">~</span><span class="str">/android-ndk-r9d/</span><span class="pln">ndk</span><span class="pun">-</span><span class="pln">depends libCoreHello</span><span class="pun">.</span><span class="pln">so <br />libCoreHello</span><span class="pun">.</span><span class="pln">so<br />libm</span><span class="pun">.</span><span class="pln">so<br />liblog</span><span class="pun">.</span><span class="pln">so<br />libdl</span><span class="pun">.</span><span class="pln">so<br />libc</span><span class="pun">.</span><span class="pln">so<br />libandroid</span><span class="pun">.</span><span class="pln">so<br />libGLESv2</span><span class="pun">.</span><span class="pln">so<br />libEGL</span><span class="pun">.</span><span class="pln">so</span></code></pre> <p><del>This is basically the list of .so files which must be contained in the APK. After I copied these to the SDK project's lib directory, together with my libCoreHello.so</del>. <strong>Update:</strong> These shared libs are not supposed to be packaged into the APK! Instead the standard system shared libraries which already exist on the device should be linked at startup. </p> <p>I finally saw the sweet, sweet ‘Hello World!’ showing up in the adb log!</p> <p>But I skipped one important part: so far I fixed everything manually, but of course I want automated Android batch builds, and without having those ugly Android skeleton project files in the git repository.</p> <p>To solve this I did a bit of cmake-fu:</p> <p>Instead of having the Android SDK project files committed into version control, I’m treating these as temporary build files.</p> <p>When cmake runs for an Android build target, it does the following additional steps:</p> <p>For each application target, a temporary Android SDK project is created in the build directory (basically the ‘android create project’ call described above):</p><div class="se-section-delimiter"></div> <pre class="prettyprint prettyprinted"><code><span class="com"># call the android SDK tool to create a new project</span><span class="pln"><br />execute_process</span><span class="pun">(</span><span class="pln">COMMAND $</span><span class="pun">{</span><span class="pln">ANDROID_SDK_TOOL</span><span class="pun">}</span><span class="pln"> create project<br />                </span><span class="pun">--</span><span class="pln">path $</span><span class="pun">{</span><span class="pln">CMAKE_CURRENT_BINARY_DIR</span><span class="pun">}/</span><span class="pln">android<br />                </span><span class="pun">--</span><span class="pln">target $</span><span class="pun">{</span><span class="pln">ANDROID_PLATFORM</span><span class="pun">}</span><span class="pln"><br />                </span><span class="pun">--</span><span class="pln">name $</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"><br />                </span><span class="pun">--</span><span class="kwd">package</span><span class="pln"> com</span><span class="pun">.</span><span class="pln">oryol</span><span class="pun">.</span><span class="pln">$</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"><br />                </span><span class="pun">--</span><span class="pln">activity </span><span class="typ">DummyActivity</span><span class="pln"><br />                WORKING_DIRECTORY $</span><span class="pun">{</span><span class="pln">CMAKE_CURRENT_BINARY_DIR</span><span class="pun">})</span></code></pre> <p>The output directory for the shared library linker step is redirected to the ‘libs’ subdirectory of this skeleton project:</p> <pre class="prettyprint prettyprinted"><code><span class="com"># set the output directory for the .so files to point to the android project's 'lib/[cpuarch] directory</span><span class="pln"><br /></span><span class="kwd">set</span><span class="pun">(</span><span class="pln">ANDROID_SO_OUTDIR $</span><span class="pun">{</span><span class="pln">CMAKE_CURRENT_BINARY_DIR</span><span class="pun">}/</span><span class="pln">android</span><span class="pun">/</span><span class="pln">libs</span><span class="pun">/</span><span class="pln">$</span><span class="pun">{</span><span class="pln">ANDROID_NDK_CPU</span><span class="pun">})</span><span class="pln"><br />set_target_properties</span><span class="pun">(</span><span class="pln">$</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"> PROPERTIES LIBRARY_OUTPUT_DIRECTORY $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />set_target_properties</span><span class="pun">(</span><span class="pln">$</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"> PROPERTIES LIBRARY_OUTPUT_DIRECTORY_RELEASE $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />set_target_properties</span><span class="pun">(</span><span class="pln">$</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"> PROPERTIES LIBRARY_OUTPUT_DIRECTORY_DEBUG $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span></code></pre> <p><del>The required system shared libraries are also copied there:</del> (DON’T DO THIS, normally the system’s standard shared libraries should be used)</p> <pre class="prettyprint prettyprinted"><code><span class="com"># copy shared libraries over from the Android toolchain directory</span><span class="pln"><br /></span><span class="com"># FIXME: this should be automated as post-build-step by invoking the ndk-depends command</span><span class="pln"><br /></span><span class="com"># to find out the .so's, and copy them over</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">libm</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">liblog</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">libdl</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">libc</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">libandroid</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">libGLESv2</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">COPY $</span><span class="pun">{</span><span class="pln">ANDROID_SYSROOT_LIB</span><span class="pun">}/</span><span class="pln">libEGL</span><span class="pun">.</span><span class="pln">so DESTINATION $</span><span class="pun">{</span><span class="pln">ANDROID_SO_OUTDIR</span><span class="pun">})</span></code></pre> <p>The default AndroidManifest.xml file is overwritten with a customized one:</p> <pre class="prettyprint prettyprinted"><code><span class="com"># override AndroidManifest.xml </span><span class="pln"><br />file</span><span class="pun">(</span><span class="pln">WRITE $</span><span class="pun">{</span><span class="pln">CMAKE_CURRENT_BINARY_DIR</span><span class="pun">}/</span><span class="pln">android</span><span class="pun">/</span><span class="typ">AndroidManifest</span><span class="pun">.</span><span class="pln">xml<br />    </span><span class="str">"&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"</span><span class="pln"><br />    </span><span class="str">"  package=\"com.oryol.${target}\"\n"</span><span class="pln"><br />    </span><span class="str">"  android:versionCode=\"1\"\n"</span><span class="pln"><br />    </span><span class="str">"  android:versionName=\"1.0\"&gt;\n"</span><span class="pln"><br />    </span><span class="str">"  &lt;uses-sdk android:minSdkVersion=\"11\" android:targetSdkVersion=\"19\"/&gt;\n"</span><span class="pln"><br />    </span><span class="str">"  &lt;uses-feature android:glEsVersion=\"0x00020000\"&gt;&lt;/uses-feature&gt;"</span><span class="pln"><br />    </span><span class="str">"  &lt;application android:label=\"${target}\" android:hasCode=\"false\"&gt;\n"</span><span class="pln"><br />    </span><span class="str">"    &lt;activity android:name=\"android.app.NativeActivity\"\n"</span><span class="pln"><br />    </span><span class="str">"      android:label=\"${target}\"\n"</span><span class="pln"><br />    </span><span class="str">"      android:configChanges=\"orientation|keyboardHidden\"&gt;\n"</span><span class="pln"><br />    </span><span class="str">"      &lt;meta-data android:name=\"android.app.lib_name\" android:value=\"${target}\"/&gt;\n"</span><span class="pln"><br />    </span><span class="str">"      &lt;intent-filter&gt;\n"</span><span class="pln"><br />    </span><span class="str">"        &lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n"</span><span class="pln"><br />    </span><span class="str">"        &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n"</span><span class="pln"><br />    </span><span class="str">"      &lt;/intent-filter&gt;\n"</span><span class="pln"><br />    </span><span class="str">"    &lt;/activity&gt;\n"</span><span class="pln"><br />    </span><span class="str">"  &lt;/application&gt;\n"</span><span class="pln"><br />    </span><span class="str">"&lt;/manifest&gt;\n"</span><span class="pun">)</span></code></pre> <p>And finally, a custom build-step to invoke the ant-build tool on the temporary skeleton project to create the final APK:</p> <pre class="prettyprint prettyprinted"><code><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">"${CMAKE_BUILD_TYPE}"</span><span class="pln"> STREQUAL </span><span class="str">"Debug"</span><span class="pun">)</span><span class="pln"><br />    </span><span class="kwd">set</span><span class="pun">(</span><span class="pln">ANT_BUILD_TYPE </span><span class="str">"debug"</span><span class="pun">)</span><span class="pln"><br /></span><span class="kwd">else</span><span class="pun">()</span><span class="pln"><br />    </span><span class="kwd">set</span><span class="pun">(</span><span class="pln">ANT_BUILD_TYPE </span><span class="str">"release"</span><span class="pun">)</span><span class="pln"><br />endif</span><span class="pun">()</span><span class="pln"><br />add_custom_command</span><span class="pun">(</span><span class="pln">TARGET $</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"> POST_BUILD COMMAND $</span><span class="pun">{</span><span class="pln">ANDROID_ANT</span><span class="pun">}</span><span class="pln"> $</span><span class="pun">{</span><span class="pln">ANT_BUILD_TYPE</span><span class="pun">}</span><span class="pln"> WORKING_DIRECTORY $</span><span class="pun">{</span><span class="pln">CMAKE_CURRENT_BINARY_DIR</span><span class="pun">}/</span><span class="pln">android</span><span class="pun">)</span></code></pre> <p>With all this in place, I can now do a:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol make </span><span class="typ">CoreHello</span><span class="pln"> android</span><span class="pun">-</span><span class="pln">make</span><span class="pun">-</span><span class="pln">debug</span></code></pre> <p>To compile and package a simple Hello World Android app!</p> <p>What’s currently missing is a simple wrapper to deploy and run an app on the device:</p> <pre class="prettyprint prettyprinted"><code><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol deploy </span><span class="typ">CoreHello</span><span class="pln"><br /></span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">./</span><span class="pln">oryol run </span><span class="typ">CoreHello</span></code></pre> <p>These would be simple wrappers around the adb tool, later this should of course also work for iOS apps.</p> <p>Right now the Android build system only works on OSX and only for the ARM V7A instruction set, and there’s no proper Android port of the actual code yet, just a single log message in the CoreHello sample.</p> <p>Phew, that’s it! All this stuff is also available on github (<a href="https://github.com/floooh/oryol/tree/master/cmake">https://github.com/floooh/oryol/tree/master/cmake</a>).</p> <blockquote>  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>