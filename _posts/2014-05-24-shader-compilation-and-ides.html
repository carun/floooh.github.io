---
layout: post
title: Shader Compilation and IDEs
date: '2014-05-24T21:02:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2014-05-24T21:14:15.974+01:00'
thumbnail: https://lh6.googleusercontent.com/-gzREEvgzCtQ/U35RnYCqwvI/AAAAAAAAAU4/ICgwmYEtiSw/s72-c/shd1.png
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-1938144798917454935
blogger_orig_url: http://flohofwoe.blogspot.com/2014/05/shader-compilation-and-ides.html
---

<p>I recently played around with shader code generation and the GLSL reference compiler in <a href="https://www.github.com/floooh/oryol">Oryol</a>.</p> <p>The result is IMHO pretty neat:</p> <p>Shader source files (*.shd) live in the IDE next to C++ files: <br><img src="https://lh6.googleusercontent.com/-gzREEvgzCtQ/U35RnYCqwvI/AAAAAAAAAU4/ICgwmYEtiSw/s0/shd1.png" alt="enter image description here" title="shd1.png"></p> <p>Shader files are written in normal GLSL syntax with custom annotations (those @ and $ tags): <br><img src="https://lh6.googleusercontent.com/-F2iZRKMRWx0/U35SAleVf1I/AAAAAAAAAVE/ZuPRLC42zTI/s0/annotated_glsl.png" alt="enter image description here" title="annotated_glsl.png"></p> <p>When compiling the project, a custom build step will generate vertex- and fragment shaders for different GLSL versions and run them through the GLSL reference compiler. Any errors from the reference compiler are converted to a format which can be parsed by the IDE:</p> <p><img src="https://lh4.googleusercontent.com/-aQFsEdwQirs/U35S7ntPaSI/AAAAAAAAAVQ/E5nweLkn9uc/s0/xcode_error.png" alt="enter image description here" title="xcode_error.png"></p> <p>Error parsing also works in Visual Studio: <br><img src="https://lh5.googleusercontent.com/-uhf5xv5altA/U35VlptsxTI/AAAAAAAAAVc/Al_nRY9tykA/s0/shd_error_vstudio.png" alt="enter image description here" title="shd_error_vstudio.png"></p> <p>Unfortunately I couldn’t get error parsing to work in QtCreator on Linux. The error messages are recognised, but double-clicking them doesn’t work.</p> <p>After the GLSL compiler pass, a C++ header/source file pair will be created which contains the GLSL shader code and some C++ glue to make the shader accessible from the engine side.</p> <p>The edit-compile-test cycle is only one or two seconds, depending on the link time of the demo code. Also, since the shader generation runs as a normal build step, shader code will also be generated and validated in command line builds.</p>   <h4 id="heres-how-it-works">Here’s how it works:</h4> <p>When <strong>cmake</strong> runs to create the build files it will look for XML files in the source code directories. For each XML file, a custom build target will be created which invokes a python script. This ‘generator script’ will generate a C++ header/source pair during compilation.</p> <p>This generic code generation has only been used so far for the Oryol Messaging system, but it is flexible enough to cover other code generation scenarios (like generating shader code).</p> <p>Setting up the custom build target involves 3 steps:</p> <p>The actual build target must be created, cmake has the <strong>add_custom_target</strong> macro for this:</p>   <pre class="prettyprint prettyprinted"><code><span class="pln">add_custom_target</span><span class="pun">(</span><span class="pln">$</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln">_gen <br />  COMMAND $</span><span class="pun">{</span><span class="pln">PYTHON</span><span class="pun">}</span><span class="pln"><br />  $</span><span class="pun">{</span><span class="pln">ORYOL_ROOT_DIR</span><span class="pun">}/</span><span class="pln">generators</span><span class="pun">/</span><span class="pln">generator</span><span class="pun">.</span><span class="pln">py<br />  $</span><span class="pun">{</span><span class="pln">xmlFiles</span><span class="pun">}</span><span class="pln"><br />  COMMENT </span><span class="str">"Generating sources..."</span><span class="pun">)</span></code></pre> <p>This statement takes a variable <em>target</em> with the name of the build target which will compile the generated C++ sources plus a <em>xmlFiles</em> list variable and it will generate a new build target called [<em>target</em>]_gen The variables PYTHON and ORYOL_ROOT_DIR are config variables pointing to the python executable and the Oryol root directory.</p> <p>To get the right build order, a target dependency must be defined so that the generated target is always run before the build target which needs the generated C++ source code:</p>   <pre class="prettyprint prettyprinted"><code><span class="pln">add_dependencies</span><span class="pun">(</span><span class="pln">$</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln"> $</span><span class="pun">{</span><span class="pln">target</span><span class="pun">}</span><span class="pln">_gen</span><span class="pun">)</span></code></pre> <p>Finally we need to resolve a chicken-egg situation. All C++ files must exist when cmake assembles the build files, but the generated C++ files will only be created during the first build. To fix this situation, empty placeholder files are created if the generated sources don’t exist yet: </p>   <pre class="prettyprint prettyprinted"><code><span class="kwd">foreach</span><span class="pun">(</span><span class="pln">xmlFile $</span><span class="pun">{</span><span class="pln">xmlFiles</span><span class="pun">})</span><span class="pln"><br />    </span><span class="kwd">string</span><span class="pun">(</span><span class="pln">REPLACE </span><span class="pun">.</span><span class="pln">xml </span><span class="pun">.</span><span class="pln">cc src $</span><span class="pun">{</span><span class="pln">xmlFile</span><span class="pun">})</span><span class="pln"><br />    </span><span class="kwd">string</span><span class="pun">(</span><span class="pln">REPLACE </span><span class="pun">.</span><span class="pln">xml </span><span class="pun">.</span><span class="pln">h hdr $</span><span class="pun">{</span><span class="pln">xmlFile</span><span class="pun">})</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">NOT EXISTS $</span><span class="pun">{</span><span class="pln">src</span><span class="pun">})</span><span class="pln"><br />        file</span><span class="pun">(</span><span class="pln">WRITE $</span><span class="pun">{</span><span class="pln">src</span><span class="pun">}</span><span class="pln"> </span><span class="str">" "</span><span class="pun">)</span><span class="pln"><br />    endif</span><span class="pun">()</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">NOT EXISTS $</span><span class="pun">{</span><span class="pln">hdr</span><span class="pun">})</span><span class="pln"><br />        file</span><span class="pun">(</span><span class="pln">WRITE $</span><span class="pun">{</span><span class="pln">hdr</span><span class="pun">}</span><span class="pln"> </span><span class="str">" "</span><span class="pun">)</span><span class="pln"><br />    endif</span><span class="pun">()</span><span class="pln"><br />endforeach</span><span class="pun">()</span><span class="pln">    </span></code></pre> <p>These 3 steps take care of the build configuration via cmake.</p>   <h4 id="on-to-the-python-generator-script">On to the python generator script:</h4> <p>First, the generator script parses the XML ‘source file’ which caused its invokation. For the shader generator, the XML file is very simple:</p>   <pre class="prettyprint prettyprinted"><code><span class="tag">&lt;Generator</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"ShaderLibrary"</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"Shaders"</span><span class="pln"> </span><span class="tag">&gt;</span><span class="pln"><br />    </span><span class="tag">&lt;AddDir</span><span class="pln"> </span><span class="atn">path</span><span class="pun">=</span><span class="atv">"shd"</span><span class="tag">/&gt;</span><span class="pln"><br /></span><span class="tag">&lt;/Generator&gt;</span></code></pre> <p>The most important piece is the <em>AddDir</em> tag which tells the generator script where it finds the actual shader source files. More then one <em>AddDir</em> can be added if the shader sources are spread over different directories.</p> <p>Generator scripts must also include a dirty-check and only actually overwrite the target C++ files when the source files (in this case: the XML file and all shader sources) are newer then the target sources to prevent unneeded compilation of dependent files. </p>   <h4 id="shader-file-parsing">Shader File Parsing</h4> <p>Shader files will be processed by a simple line-parser:</p> <ol><li>comments and white-space will be removed</li><li>find and process ‘@’ and ‘$’ keywords</li><li>gather GLSL code lines and keep track of their source file and line numbers (this is important for mapping error messages back later)</li></ol> <p>A very minimal shader file looks like this:</p>   <pre class="prettyprint prettyprinted"><code><span class="lit">@vs</span><span class="pln"> </span><span class="typ">MyVertexShader</span><span class="pln"><br /></span><span class="lit">@uniform</span><span class="pln"> mat4 mvp </span><span class="typ">ModelViewProj</span><span class="pln"><br /></span><span class="lit">@in</span><span class="pln"> vec4 position<br /></span><span class="lit">@in</span><span class="pln"> vec2 texcoord0<br /></span><span class="lit">@out</span><span class="pln"> vec2 uv<br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  $position </span><span class="pun">=</span><span class="pln"> mvp </span><span class="pun">*</span><span class="pln"> position</span><span class="pun">;</span><span class="pln"><br />  uv </span><span class="pun">=</span><span class="pln"> texcoord0</span><span class="pun">;</span><span class="pln"><br /></span><span class="lit">@end</span><span class="pln"><br /><br /></span><span class="lit">@fs</span><span class="pln"> </span><span class="typ">MyFragmentShader</span><span class="pln"><br /></span><span class="lit">@uniform</span><span class="pln"> sampler2D tex </span><span class="typ">Texture</span><span class="pln"><br /></span><span class="lit">@in</span><span class="pln"> vec2 uv<br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  $color </span><span class="pun">=</span><span class="pln"> $texture2D</span><span class="pun">(</span><span class="pln">tex</span><span class="pun">,</span><span class="pln"> uv</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="lit">@end</span><span class="pln"><br /><br /></span><span class="lit">@bundle</span><span class="pln"> </span><span class="typ">Main</span><span class="pln"><br /></span><span class="lit">@program</span><span class="pln"> </span><span class="typ">MyVertexShader</span><span class="pln"> </span><span class="typ">MyFragmentShader</span><span class="pln"><br /></span><span class="lit">@end</span></code></pre> <p>This defines one vertex shader (between the <strong>@vs</strong> and <strong>@end</strong> tags) and a matching fragment shader (between <strong>@fs</strong> and <strong>@end</strong>). The vertex shader defines a 4x4 matrix uniform with the GLSL variable name <em>mvp</em> and the ‘bind name’ <em>ModelViewProj</em>, and it expects position and texture coordinates from the vertex. The vertex shader transforms the vertex-position into the special variable $position and forwards the texture coordinate to the fragment shader.</p> <p>The fragment shader defines a texture sampler uniform with the GLSL variable name <em>tex</em> and the bind name <em>Texture</em>. It takes the texture coordinates emitted by the vertex shader, samples the texture and writes the color into the special variable $color.</p> <p>Finally a shader <strong>@bundle</strong> with the name ‘Main’ is defined, and one shader program created from the previously defined vertex- and fragment-shader is attached to the bundle. A shader bundle is an Oryol-specific concept and is simply a collection of one or more  shader programs that are related to each other.</p> <p>Another useful tag which isn’t used in this simple example are the <strong>@block</strong> and <strong>@use</strong> tag. A @block encapsulates a piece of code which can then later be included with a @use tag in other blocks or vertex-/fragment-shaders. This is basically the missing <strong>#include</strong> mechanism for GLSL files.</p> <p>Here’s some @block sample code, first a <em>Util</em> block is defined with general utility functions, then a block <em>VSLighting</em> which would contain lighting functions for vertex shaders, and <em>FSLighting</em> with lighting functions for fragment shaders. Both VSLighting and FSLighting want to use functions from the Util block (via <strong>@use Util</strong>). Finally the vertex- and fragment-shaders would contain a <em>@use VSLighting</em> and <em>@use FSLighting</em> (not shown). The shader code generator would then resolve all block dependencies and include the required the code blocks in the generated shader source in the right order:</p>   <pre class="prettyprint prettyprinted"><code><span class="lit">@block</span><span class="pln"> </span><span class="typ">Util</span><span class="pln"><br /></span><span class="com">// general utility functions</span><span class="pln"><br />vec4 bla</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  vec4 result</span><span class="pun">;</span><span class="pln"><br />  </span><span class="pun">...</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="lit">@end</span><span class="pln"><br /><br /></span><span class="lit">@block</span><span class="pln"> </span><span class="typ">VSLighting</span><span class="pln"><br /></span><span class="com">// lighting functions for the vertex shader</span><span class="pln"><br /></span><span class="lit">@use</span><span class="pln"> </span><span class="typ">Util</span><span class="pln"><br />vec4 vsBlub</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> bla</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="lit">@end</span><span class="pln"> <br /><br /></span><span class="lit">@block</span><span class="pln"> </span><span class="typ">FSLighting</span><span class="pln"><br /></span><span class="com">// lighting functions for the fragment shader</span><span class="pln"><br /></span><span class="lit">@use</span><span class="pln"> </span><span class="typ">Util</span><span class="pln"><br />vec4 fsBlub</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> bla</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="lit">@end</span></code></pre>   <h4 id="glsl-code-generation-and-validation">GLSL Code Generation and Validation</h4> <p>From the ‘tagged shader source’, the shader generator script will create actual vertex- and fragment-shader code for different GLSL versions and feed it to the reference compiler for validation.</p> <p>For instance, the above simple vertex/fragment-shader source would produce the following GLSL 1.00 source code (for OpenGLES2 and WebGL):</p>   <pre class="prettyprint prettyprinted"><code><span class="pln">uniform mat4 mvp</span><span class="pun">;</span><span class="pln"><br />attribute vec4 position</span><span class="pun">;</span><span class="pln"><br />attribute vec2 texcoord0</span><span class="pun">;</span><span class="pln"><br />varying vec2 uv</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  gl_Position </span><span class="pun">=</span><span class="pln"> mvp </span><span class="pun">*</span><span class="pln"> position</span><span class="pun">;</span><span class="pln"><br />  uv </span><span class="pun">=</span><span class="pln"> texcoord0</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>The output for a more modern GLSL version would look slightly different:</p> <pre class="prettyprint prettyprinted"><code><span class="com">#version 150</span><span class="pln"><br />uniform mat4 mvp</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">in</span><span class="pln"> vec4 position</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">in</span><span class="pln"> vec2 texcoord0</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">out</span><span class="pln"> vec2 uv</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  gl_Position </span><span class="pun">=</span><span class="pln"> mvp </span><span class="pun">*</span><span class="pln"> position</span><span class="pun">;</span><span class="pln"><br />  uv </span><span class="pun">=</span><span class="pln"> texcoord0</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>The GLSL reference compiler is called once per GLSL version and vertex-/fragment-shader and the resulting output is captured into a string variable. The python code to start an exe and capture its output looks like this:</p> <pre class="prettyprint prettyprinted"><code><span class="pln">child </span><span class="pun">=</span><span class="pln"> subprocess</span><span class="pun">.</span><span class="typ">Popen</span><span class="pun">([</span><span class="pln">exePath</span><span class="pun">,</span><span class="pln"> glslPath</span><span class="pun">],</span><span class="pln"> stdout</span><span class="pun">=</span><span class="pln">subprocess</span><span class="pun">.</span><span class="pln">PIPE</span><span class="pun">)</span><span class="pln"><br /></span><span class="kwd">out</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pln"><br /></span><span class="kwd">while</span><span class="pln"> </span><span class="kwd">True</span><span class="pln"> </span><span class="pun">:</span><span class="pln"><br />    </span><span class="kwd">out</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">stdout</span><span class="pun">.</span><span class="pln">read</span><span class="pun">()</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">poll</span><span class="pun">()</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">None</span><span class="pln"> </span><span class="pun">:</span><span class="pln"><br />        </span><span class="kwd">break</span><span class="pln"><br /></span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">out</span></code></pre> <p>The output will then be parsed for error messages and error line numbers. Since these line-numbers are pointing into the generated source code they are not useful themselves but must be mapped back to the original source-file-path and line-numbers. This is why the line-parser had to store this information with each extracted source code line.</p> <p>The mapped source-file-path, line-number and error message must then be formatted into the gcc/clang- or VStudio-error-message format, and if an error occurs, the python script will terminate with an error code so that the build is stopped:</p>   <pre class="prettyprint prettyprinted"><code><span class="kwd">if</span><span class="pln"> platform</span><span class="pun">.</span><span class="pln">system</span><span class="pun">()</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">'Windows'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"><br />    </span><span class="kwd">print</span><span class="pln"> </span><span class="str">'{}({}): error: {}'</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="typ">FilePath</span><span class="pun">,</span><span class="pln"> </span><span class="typ">LineNumber</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> msg</span><span class="pun">)</span><span class="pln"><br /></span><span class="kwd">else</span><span class="pln"> </span><span class="pun">:</span><span class="pln"><br />    </span><span class="kwd">print</span><span class="pln"> </span><span class="str">'{}:{}: error: {}\n'</span><span class="pun">.</span><span class="pln">format</span><span class="pun">(</span><span class="typ">FilePath</span><span class="pun">,</span><span class="pln"> </span><span class="typ">LineNumber</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> msg</span><span class="pun">)</span><span class="pln"><br /></span><span class="kwd">if</span><span class="pln"> terminate</span><span class="pun">:</span><span class="pln"><br />    sys</span><span class="pun">.</span><span class="kwd">exit</span><span class="pun">(</span><span class="lit">10</span><span class="pun">)</span></code></pre> <p>This formatting works for Xcode and VisualStudio. The error is displayed by the IDE and can be double-clicked to position the text cursor over the right source code location. It doesn’t work in Qt Creator yet unfortunately, and I haven’t tested Eclipse yet.</p> <p>Another thing to keep in mind is that build jobs can run in parallel. At first I was writing the intermediate GLSL files for the reference compiler into files with simple filenames (like ‘vs.vert’ and ‘fs.frag’). This didn’t cause any problems when doing trivial tests, but once I had converted all Oryol samples to use the shader generator I was sometimes getting weird errors from the reference compiler which didn’t make any sense at first.</p> <p>The problem was that build jobs were running at the same time and overwrote each others intermediate files. The solution was to use randomized filenames which cannot collide. As always, python has a module just for this case called ‘tempfiles’:</p>   <pre class="prettyprint prettyprinted"><code><span class="com"># this writes to a new temp vertex shader file </span><span class="pln"><br />f </span><span class="pun">=</span><span class="pln"> tempfile</span><span class="pun">.</span><span class="typ">NamedTemporaryFile</span><span class="pun">(</span><span class="pln">suffix</span><span class="pun">=</span><span class="str">'.vert'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">delete</span><span class="pun">=</span><span class="kwd">False</span><span class="pun">)</span><span class="pln"><br />writeFile</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class="pln"> lines</span><span class="pun">)</span><span class="pln"><br />f</span><span class="pun">.</span><span class="pln">close</span><span class="pun">()</span><span class="pln"><br /><br /></span><span class="com"># call the validator</span><span class="pln"><br /></span><span class="pun">...</span><span class="pln"><br /><br /></span><span class="com"># delete the temp file when done</span><span class="pln"><br />os</span><span class="pun">.</span><span class="pln">unlink</span><span class="pun">(</span><span class="pln">f</span><span class="pun">.</span><span class="pln">name</span><span class="pun">)</span></code></pre>   <h4 id="the-c-side">The C++ Side</h4> <p>Last but not least a quick look at the generated C++ source code. The C++ header defines a namespace with the name of the shader-library, and one class per shader-bundle. The very simple vertex/fragment-shader sample from above would generate a header like this:</p>   <pre class="prettyprint prettyprinted"><code><span class="com">#pragma</span><span class="pln"> once<br /></span><span class="com">/*  #version:1#<br />    machine generated, do not edit!<br />*/</span><span class="pln"><br /></span><span class="com">#include</span><span class="pln"> </span><span class="str">"Render/Setup/ProgramBundleSetup.h"</span><span class="pln"><br /></span><span class="kwd">namespace</span><span class="pln"> </span><span class="typ">Oryol</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br /></span><span class="kwd">namespace</span><span class="pln"> </span><span class="typ">Shaders</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br /></span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Main</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br /></span><span class="kwd">public</span><span class="pun">:</span><span class="pln"><br />  </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> int32 </span><span class="typ">ModelViewProj</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> int32 </span><span class="typ">Texture</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Render</span><span class="pun">::</span><span class="typ">ProgramBundleSetup</span><span class="pln"> </span><span class="typ">CreateSetup</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">};</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>Note the ModelViewProj and Texture constant definitions. These are used to set the uniform values in the C++ render loop.</p> <p>How this code is actually used for rendering is a topic of its own. For now let me just point to the Oryol sample source code:</p> <p><a href="https://github.com/floooh/oryol/tree/master/code/Samples/Render">https://github.com/floooh/oryol/tree/master/code/Samples/Render</a></p>   <h4 id="whats-next">What’s next</h4> <p>The existing shader tags are already quite useful but only the beginning. The real problem I want to solve is to manage slightly differing variations of the same shader. For instance there might exist a specific high-level material, which must be applied to static and skinned geometry (2 variations), can cast shadows (4 variations: static shadow caster, skinned shadow caster), should be available in a forward-renderer and deferred-renderer (== many more slightly different shader variations). Sometimes an ueber-shader approach is better, and sometimes actually separate shaders for each variation are better. </p> <p>The guts of those material shaders are always built from the same small code fragments, just arranged and combined differently.</p> <p>Hopefully a couple of new ‘@’ and ‘$’ tags will be enough, but how this will look like in detail I don’t know yet. One inspiration are web-template engines which build web pages from a set of templates and rules. Another inspiration are the existing connect-the-dots shader editors (even though I want to keep the focus on ‘shaders-as-source-code’, not ‘shader-as-data’, but some limited runtime-code-generation would still make sense).</p> <p>And of course the right middle-ground between ‘modern GLSL’ and ‘legacy GLSL’ must be found. Unfortunately OpenGL ES2 / WebGL1.0 will have to be the foundation for quite some time.</p> <p>And that’s all for today :)</p> <blockquote>  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>