---
layout: post
title: 'emscripten and PNaCl: App entry in emscripten'
date: '2013-09-01T14:21:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2013-09-01T14:32:04.925+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-4345717290220329482
blogger_orig_url: http://flohofwoe.blogspot.com/2013/09/emscripten-and-pnacl-app-entry-in.html
---

<p>When quickly hacking a graphics demo on the PC or consoles, the main function usually looks like this:</p> <pre><code>int main() <br />{<br />    if (Initialize()) <br />    {<br />        while (!Finished()) <br />        {<br />            Update();<br />            Render();<br />        }<br />        Cleanup();<br />    }<br />    return 0;<br />}<br /></code></pre> <p>Trying this in on one of the browser platforms like emscripten or PNaCl results in a freeze and after a little while the browser will kill your tab :(</p> <p>The problem is that the browser won't "let you own the game loop", and this is a general problem of event- or callback-driven platforms (iOS and Android have the same problem for instance). On such platforms the execution flow of the main thread is not controlled by your game code, instead there's some outer event loop which will call into your code from time to time. If you spent too much time in your allotted slice of the pie you will drag the entire system event loop down and other important events (such as input events) can't be handled fast enough. Result is that the entire user interface will feel sluggish and unresponsive to the user (for instance, scrolling in your browser tab will stutter or even freeze for multiple seconds). And if you don't return for about 30 seconds, then the browser will kill your app (Aw Snap!).</p> <p>This is all bad user experience of course, we want the browser to remain responsive, and scrolling smooth <strong>all</strong> the time, also during initialisation and load time.</p> <p>The core problem is that your code <strong>must always</strong> return within a few milliseconds back to the browser (e.g. 16 or 33, depending on whether you're aiming for 60 or 30fps), and this is the big riddle we need to solve for a game application running in a browser.</p> <p>For a Flash or Javascript coder, or someone who's mainly writing event-driven UI applications this will all be familiar, they are used to have all their code run inside event handlers and callbacks, but typical UI apps usually don't need to do anything continuous. Event-driven applications sleep most of the time, react to (mostly input-) events from the outside, and go to sleep again. But games need to do continuous rendering, and thus are <strong>frame-driven</strong>, not <strong>event-driven</strong>, and mixing these two programming models isn't a very good idea because its hard to follow the code-flow. The usual way to implement games on event-driven platforms is to setup a timer which calls a per-frame callback function many times per second. I think hacks like this is why game programmers have a deep hatred for UI-centric platforms (and why I still like Windows despite its other shortcomings, because the recommended event handling model in Windows for games (PeekMessage -&gt; TranslateMessage -&gt; DispatchMessage) actually lets you "own the game loop" in a very simple and elegant way through message polling).</p> <p>There are a few different approaches to either get a true continuous game loop, or at least to create the illusion of a continuous game loop on platforms where polling isn't possible, mainly depending on whether "true" pthreads-style multi-threading is supported or not.</p> <p>In a Nebula3/emscripten application this isn't the case, the actual game loop and the rendering code runs on the main thread. Reason for this is that emscripten's multithreading support is built on WebWorkers. pthreads emulation isn't possible in emscripten since WebWorkers can't share memory with the main thread, furthermore, WebWorkers can't call into WebGL. This puts a lot of restrictions on our "game loop problem", and it required to refactor Nebula3's application model: in all previous ports there was always a way to somehow run a continuous game loop, mostly by moving the game loop into its own thread, but we don't have this option in emscripten (yet ... but hopefully one day, with more flexible WebWorkers).</p> <p>Traditionally, a Nebula3 application used to go through a simple "Open -&gt; Run -&gt; Close -&gt; Exit" sequence. An N3 main file looked like this for instance:</p> <pre><code>#include "myapplication.h"<br /><br />ImplementNebulaApplication();<br /><br />void<br />NebulaMain(const Util::CommandLineArgs&amp; args)<br />{<br />    MyApplication app;<br />    app.SetCommandLineArgs(args);<br />    if (app.Open())<br />    {<br />        app.Run();<br />        app.Close();<br />    }<br />    app.Exit();<br />}<br /></code></pre> <p>Instead of a main() function, there's a NebulaMain() wrapper function and a macro called <em>ImplementNebulaApplication()</em>. These hide the fact that not all platforms have a standard main() (for a Windows application, one would typically use WinMain() for instance).</p> <p>The actual system main function is hidden inside the <em>ImplementNebulaApplication()</em> macro, for a PC-like platform the macro code looks like this:</p> <pre><code>int __cdecl main(int argc, const char** argv)<br />{<br />    Util::CommandLineArgs args(argc, argv);<br />    return NebulaMain(args);<br />}<br /></code></pre> <p>Now back up to the NebulaMain() function's content: the Application::Open() method could take a while to execute (couple of seconds, worst case), and the Application::Run() will contain the "infinite" game loop, which only returns when the application should quit.</p> <p>Since this wasn't a very good fit for the emscripten platform (because of this "infinite" loop inside the Run() method), first step was to make the app entry even more abstract to give the platform-specific code more wiggle room:</p> <pre><code>#include "myapplication.h"<br /><br />ImplementNebulaApplication();<br /><br />void<br />NebulaMain(const Util::CommandLineArgs&amp; args)<br />{<br />    static MyApplication* app = new MyApplication();<br />    app-&gt;SetCommandLineArgs(args);<br />    app-&gt;StartMainLoop();<br />}<br /></code></pre> <p>The most obvious change is that there's only a single StartMainLoop() method instead of the Open-&gt;Run-&gt;Close-&gt;Exit sequence. And at closer inspection some strange stuff is going on here: The application object is now created on the heap, the pointer to the object lives in the global scope, and the app object is never deleted. WTF?!?</p> <p>To understand what's going on we need to dive a bit deeper into the emscripten system API.</p> <p>The StartMainLoop function is actually only a one-liner on the emscripten platform:</p> <pre><code>emscripten_set_main_loop(OnPhasedFrame, 0, 0);<br /></code></pre> <p>This sets the per-frame callback (called OnPhasedFrame) which the browser runtime will call regularly, and we'll have to do <strong>everything</strong> inside this callback function. The first 0-arg is the intended callback frequency per second (e.g. 60). 0 has a special meaning: in this case emscripten is using the modern requestAnimationFrame mechanism to call our per-frame function (instead of of the old-school setInterval or setTimeout way). The second argument is called simulateInfiniteLoop, and to understand what this does it is first necessary to understand what happens when it is <em>not</em> used:</p> <p>The emscripten_set_main_loop() function will simply return, all the way up to main(), which will also return right after it has started! WTF indeed...</p> <p>In a normal C program, returning from the main() function means that the program is shutting down of course. Local-scope objects will be destroyed before leaving main(), then global-scope objects (static initialisers).</p> <p>In emscripten's case, a program which has called emscripten_set_main_loop() continues to run after main() has returned. This is a bit of a strange design decision, but makes for familiar looking code (e.g. hello_world.cpp is the same as on any other platform). Objects in the global scope <strong>will continue to exist</strong> in emscripten after main() returns, but objects in the local scope of main() will be destroyed, thus this strange way to create our application object, to prevent the app object from being destroyed after main() is left:</p> <pre><code>    static MyApplication* app = new MyApplication();<br /></code></pre> <p>And now back to that <strong>simulate_infinite_loop</strong> argument: This is a new argument which was introduced after I started the Nebula3 emscripten port.  Setting this argument to 1 will cause the emscripten_set_main_loop() function to not return to the caller, instead a Javascript exception will be thrown which essentially means that execution bails out of the C/C++ code without unwinding the (C/C++) stack, thus leaving local-scope objects of the main() function alive, everything after emscripten_set_main_loop() will never be called. So with this fix we could just as well write:</p> <pre><code>void<br />NebulaMain(const Util::CommandLineArgs&amp; args)<br />{<br />    MyApplication app;<br />    app.SetCommandLineArgs(args);<br />    app.StartMainLoop();<br />}<br /></code></pre> <p>Which looks a lot more friendly indeed.</p> <p>So this basically covered emscripten's application startup process, we now have a per-frame function (called OnPhasedFrame) which will be called back at 60 fps. We just need to cram everything the application has to do into these 1/60sec time slices. This is fine for the actual game loop after everything has been loaded and initialised, but can be a problem for stuff like loading a new level, which could take a couple of seconds. In a traditional game, worst thing that could happen in this case is that the loading screen animation (if there is any) may stutter, but in a browser environment, such pauses will affect the entire browser tab (freezing, no scrolling, etc...), which makes a very bad first impression to the user.</p> <p>So what to do? For Nebula3 I created a new Application base class called "PhasedApplication". Such a phased application goes through different life time phases (== states), such as:</p> <pre><code>Initial     -&gt; app has just become alive<br />Preloading  -&gt; currently preloading data<br />Opening     -&gt; currently initializing<br />Running     -&gt; currently running the game loop<br />Closing     -&gt; currently shutting down<br />Quit        -&gt; shutting down has finished<br /></code></pre> <p>Each of these phases (or states) has an associated per-frame callback method (OnInitial, OnPreloading, OnOpening, etc...). The central per-frame callback will simply call into one of those methods based on the current phase/state. Each phase method invocation must return quickly (the browser's responsiveness depends on this), and may be called many times until the next phase is activated. So instead of doing a lot of stuff in a single frame, we do many small things across many frames.</p> <p>Best example to illustrate this is the OnOpening() method. Suppose we need to do a lot of initialisation work during the apps Opening phase. Files need to be loaded, subsystems must be initialised and so on. This may take a couple of seconds. But the rule is that we must ideally return within 1/60sec, and we also don't have an independent render thread which could hide the main-thread freeze behind a smooth loading animation. So we need to do just a little bit of initialisation work, possibly update rendering of the loading screen, and return to the browser runtime. But since we haven't switched to the next state yet, OnOpening() will be called back again, and we can do the next piece of initialisation work. Sounds awkward of course, and it is, but there's not a lot we can do about it. </p> <p>A new Javascript concept called <strong>generators</strong> could help to clean up this mess, with these it should be possible to chop a long sequence of actions into small slices while leaving the function context intact (essentially like a yield() function in a cooperative multithreading system) - catapulting Javascript into the illustrious company of Windows1.x and Classic MacOS. But enough with the ranting ;)</p> <p>A somewhat cleaner method for long initialisation work is starting asynchronous actions through a WebWorker job in the first call to OnOpening() and during the next OnOpening calls check for all of those actions to have finished, gather the results, and finally switch to the next state, which would be <em>Running</em>. In the worst case, initialisation code must literally be chopped into little slices running on the main thread.</p> <p>So that's it for this blog post. Originally I wanted to compare emscripten's and PNaCl startup process, but this would be way too much text for a single posts, so next will very likely be a similar walk through of the PNaCl application start, and after that the next big topic: how to handle asset loading.</p> <blockquote>  <p>Written with <a href="http://benweet.github.io/stackedit/">StackEdit</a>.</p></blockquote>