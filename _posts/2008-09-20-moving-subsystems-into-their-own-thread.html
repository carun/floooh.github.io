---
layout: post
title: Adding functionality to threaded subsystems
date: '2008-09-20T15:14:00.002+01:00'
author: Andre Weissflog
tags:
- Nebula3
modified_time: '2008-09-20T15:25:15.472+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-7644679602438493486
blogger_orig_url: http://flohofwoe.blogspot.com/2008/09/moving-subsystems-into-their-own-thread.html
---

Moving subsystems into their own thread introduces restrictions on how other threads can interact with the subsystem. It is no longer possible to simply invoke methods on objects running in the context of a threaded subsystem. The only way to interact with the subsystem is by sending messages to it. From a system design point-of-view this is a good thing. There's a very clear demarcation line defined by the message protocol to interact with the subsystem. It is pretty much impossible to invoke undocumented functionality from the outside and it is complicated to "accidently" use the subsystem's functionality in a way not intended by the subsystem's designer.<div><br /></div><div>But of course those restrictions also have their dark side. All tasks which either require a lot of communication, or which require exact synchronization should better not be spread across threads. Although the messaging system is fast (and will remain an optimization hotspot) it is not free, it's not a good idea to send thousands (or even hundreds) of messages around per-frame. Also, a message sender should never wait for the completion of a message to work around the synchronization problem (at least not while the game loop is running), as this would pretty much nullify the advantage of running the subsystem in its own thread.</div><div><br /></div><div>Nebula3 offers a relatively simple way to add functionality which shall run in the context of a subsystem thread. The basic idea is to create a new message-handler class (which is running in the subsystem's thread) and a new set of messages which can be processed by an instance of the new handler-class.</div><div><br /></div><div>We recently did this to add debug-visualization capability to Nebula3. We wanted to have a simple way to (a) render debug text, and (b) render shapes (cubes, spheres, etc...) to make it simple to render debug-visualizations from anywhere in Nebula3.</div><div><br /></div><div>The whole system is split into 3 parts:</div><div><br /></div><ul><li>The <b>front-end classes</b> running on the client-side (client-side means: every thread other then the render thread):</li><ul><li>the <b>Debug::DebugTextRenderer</b> singleton offers text rendering</li><li>the <b>Debug::DebugShapeRenderer </b>singleton offers shape rendering</li><li>both are thread-local singletons, each thread which wants to render debug text or shapes needs to instantiate those</li></ul><li>The <b>back-end classes</b> running in the render-thread:</li><ul><li>CoreGraphics::TextRenderer</li><li>CoreGraphics::ShapeRenderer</li><li>these singletons implement the actual text- and shape-rendering functionality and are also platform-specific (under Windows, they use D3DX methods to do their jobs)</li></ul><li>The <b>communication components</b>:</li><ul><li>the Debug Render message protocol, this is a NIDL-XML-file (Nebula Interface Definition Language) which defines 2 messages: <b>RenderDebugText</b> and <b>RenderDebugShapes</b></li><li>the <b>DebugGraphicsHandler</b> object, whose class is derived from Messaging::Handler, runs in the render thread, and processes the above 2 messages </li></ul></ul><br /><div>This is how the system works:</div><div><br /></div><div><ol><li>the main thread instructs the GraphicsInterface singleton (which creates and manages the render-thread) to add a DebugGraphicsHandler object (that's at least how it SHOULD work,  at the moment, the GraphicsHandler simply creates and attaches a DebugGraphicsHandler on its own)</li><li>client threads create one DebugTextRenderer and one DebugShapeRenderer singleton if they want to do debug visualization</li><li>a client-thread calls directly one of the DebugTextRenderer or DebugShapeRenderer methods to render text or shapes</li><li>the DebugTextRenderer and DebugShapeRenderer singletons collect a whole frame's worth of text elements and shapes and once per frame, create a single RenderDebugText and RenderDebugShapes message, so at most only 2 messages are sent into the render thread per-frame from each client-thread, not one message per shape and text element, that's a very important optimization!</li><li>Once per render-frame, the DebugGraphicsHandler processes incoming RenderDebugText and RenderDebugShapes by calling the CoreGraphics::TextRenderer and CoreGraphics::ShapeRenderer singletons</li></ol><div><br /></div><div>That's it basically. Nebula3 applications can add their own functionality to subsystem threads by following the described pattern.</div><div><br /></div><div>With the first naive implementation we stumbled across an obvious problem: when the main-thread runs slower then the graphics thread, debug shapes and text would start to flicker, since the render thread would only receive render-debug-messages every other frame. So we had to add a way to identify shapes and text elements by their origin-thread-id, and keep them around until the next message comes in from the same thread, but this was a trivial thing to do.</div><div><br /></div><div>A positive effect is that debug visualization no longer needs to happen at a specific point in the render loop. This was a problem in Nebula2/Mangalore where classes had to provide an "OnRenderDebug()" method which was called by the rendering system from within the render loop. Instead debug visualization can now happen from anywhere in the code (although at the cost of some more memory and communications overhead, but especially debug visualizations is an area where convenience and ease-of-use is more important then raw performance).</div><div><br /></div><div>FYI, this is how the NIDL-file looks like, which defines the messages of the DebugRender protocol:</div><div><br /></div><div><table id="e1q." width="100%" cellpadding="3" cellspacing="0" border="0" class="zeroBorder" bgcolor="#fff2cc"><tbody><tr><td width="100%"><div style="margin-top: 0px; margin-bottom: 0px">&lt;?xml version="1.0" encoding="utf-8"?></div><div style="margin-top: 0px; margin-bottom: 0px"><div style="margin-top: 0px; margin-bottom: 0px">&lt;Nebula3></div><div style="margin-top: 0px; margin-bottom: 0px">    &lt;Protocol namespace="Debug" name="DebugRenderProtocol"></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;!-- dependencies --></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;Dependency header="util/array.h"/></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;Dependency header="threading/threadid.h"/></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;Dependency header="coregraphics/textelement.h"/></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;Dependency header="debugrender/debugshaperenderer.h"/></div><div style="margin-top: 0px; margin-bottom: 0px"><br /></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;!-- render text string on screen for debugging --></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;Message name="RenderDebugText" fourcc="rdtx">            </div><div style="margin-top: 0px; margin-bottom: 0px">            &lt;InArg name="ThreadId" type="Threading::ThreadId"/></div><div style="margin-top: 0px; margin-bottom: 0px">            &lt;InArg name="TextElements" type="Util::Array&lt;CoreGraphics::TextElement>" /></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;/Message></div><div style="margin-top: 0px; margin-bottom: 0px"><br /></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;!-- render debug shapes --></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;Message name="RenderDebugShapes" fourcc="rdds"></div><div style="margin-top: 0px; margin-bottom: 0px">            &lt;InArg name="ThreadId" type="Threading::ThreadId"/></div><div style="margin-top: 0px; margin-bottom: 0px">            &lt;InArg name="Shapes" type="Util::Array&lt;CoreGraphics::Shape>" /></div><div style="margin-top: 0px; margin-bottom: 0px">        &lt;/Message></div><div style="margin-top: 0px; margin-bottom: 0px"><br /></div><div style="margin-top: 0px; margin-bottom: 0px">    &lt;/Protocol></div><div style="margin-top: 0px; margin-bottom: 0px">&lt;/Nebula3>    </div></div></td></tr></tbody></table></div><div>    </div><div>This will be compiled by the Nebula3 NIDL-compiler-tool into one C++ header and one source file (debugrenderprotocol.h and debugrenderprotocol.cc). </div><div><br /></div><div>I hope to have a new source drop out "really-soon-now", so you can check for yourself what I'm actually talking about :)</div><div><br /></div></div>