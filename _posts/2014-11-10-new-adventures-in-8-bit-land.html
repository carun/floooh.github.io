---
layout: post
title: New Adventures in 8-Bit Land
date: '2014-11-10T00:41:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2014-11-10T00:41:30.912+01:00'
thumbnail: https://lh3.googleusercontent.com/-qTAnPdyio1s/VF_lNqLpenI/AAAAAAAAAaM/XfWHIHvjsFk/s72-c/mess_kc85_3.png
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-4210908639079415377
blogger_orig_url: http://flohofwoe.blogspot.com/2014/11/new-adventures-in-8-bit-land.html
---

<p>Alan Cox’ recent <a href="https://plus.google.com/111104121194250082892/posts/a2jAP7Pz1gj">announcement</a> of his Unix-like operating system for old home computers got me thinking: wouldn’t it be cool write programs for the KC85/3 in C, a language it never officially supported? </p> <p>For youngsters and Westerners: the <a href="http://en.wikipedia.org/wiki/Robotron_KC_85">KC85 home computer line</a> was built in the 80’s in Eastern Germany, the most popular version, the KC85/3 had a 1.75MHz Z80-compatible CPU, and 16kByte each of general RAM, video RAM and ROM (so 32kByte RAM and 16kByte ROM). The ROM was split in half, 8kByte BASIC, 8kByte OS. Display was 320x256 pixels, a block of 8x4 pixels could have 1-out-of-16 foreground and 1-out-of-8 background colors. No sprite support, no dedicated sound chip, and the video RAM layout was extra-funky and had very slow CPU access.</p> <p><a href="https://github.com/mamedev/mame">MAME/MESS</a> has rudimentary support for the KC85 line (and many other computers built behind the Iron Curtain) and I dabbled with the KC85 emulation in JSMESS a while ago, as can be seen here: <a href="http://www.flohofwoe.net/history.html">http://www.flohofwoe.net/history.html</a>. So far this dabbling was all about running old games on old (emulated) machines.</p>   <h3 id="new-code-on-old-machines">New Code on Old Machines</h3> <p>But what about running new code on old machines? And not just Z80 assembler code, but ‘modern’ C99 code? </p> <p>Good 8-bit C compilers are surprisingly easy to find, since the Z80 lived on well into the 2000s for embedded systems. I first started looking for a Z80 LLVM backend, but after some more googling I decided to go for <a href="http://sdcc.sourceforge.net/">SDCC</a>, which looks like the ‘industry standard’ for 8-bit CPUs and is still actively developed.</p> <p>On OSX, a recent SDCC can be installed with brew:</p> <pre class="prettyprint"><code class=" hljs markdown"><span class="hljs-blockquote">&gt; brew install sdcc</span></code></pre> <p>After I played a few minutes with the compiler I decided that starting right with C is a few steps too far.</p>   <h3 id="mess">MESS</h3> <p>First I had to get MESS running again. MESS is the son of MAME, focusing on vintage computer emulation instead of arcade machines. Since I last used it, MESS had been merged back into MAME, and development has been moved onto github: <a href="https://github.com/mamedev/mame">https://github.com/mamedev/mame</a></p> <p>So first, git-clone and compile mess:</p> <pre class="prettyprint"><code class=" hljs markdown"><span class="hljs-blockquote">&gt; git clone git@github.com:mamedev/mame.git mame</span><br /><span class="hljs-blockquote">&gt; cd mame</span><br /><span class="hljs-blockquote">&gt; make TARGET=mess</span></code></pre> <p>This produces a ‘mess64’ executable on OSX. Next KC85/3 and /4 system ROMs are needed, these can be found by googling for ‘kc85_3.zip MESS’ (for what it’s worth, I consider these ROMs abandonware). With the compiled mess and the ROMs, a KC85/3 session can now be started in MESS:</p> <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-subst">&gt;</span><span class="hljs-built_in">.</span>/mess64 kc85_3 <span class="hljs-attribute">-rompath</span> <span class="hljs-built_in">.</span> <span class="hljs-attribute">-window</span> <span class="hljs-attribute">-resolution</span> <span class="hljs-number">640</span>x512</code></pre> <p>And here we go: <br><img src="https://lh3.googleusercontent.com/-qTAnPdyio1s/VF_lNqLpenI/AAAAAAAAAaM/XfWHIHvjsFk/s0/mess_kc85_3.png" alt="enter image description here" title="mess_kc85_3.png"></p> <h3 id="getting-stuff-into-mess">Getting stuff into MESS</h3> <p>Next we need to figure out how to get code onto the emulator. The KC85 operating system ‘CAOS’ (for **C**assete **A**ided **O**perating **S**ystem - yes even East-German engineers had a sense for humor) didn’t have an ‘executable format’ like ELF, instead raw chunks of code and data were loaded from cassette tapes into memory. There was however a standardised format of how the data was stored on tape. Divided into chunks of 128 bytes, with the first chunk being the header with information at which address to load the following data. This tape format has survived as the ‘KCC file format’, where the first 128-byte chunk looks like this (taken from the <a href="https://github.com/mamedev/mame/blob/master/src/mess/machine/kc.c#L10">kc85.c MESS driver source code</a>):</p> <pre class="prettyprint"><code class=" hljs scss">struct kcc_header<br />{<br />    UINT8   name<span class="hljs-attr_selector">[10]</span>;<br />    UINT8   reserved<span class="hljs-attr_selector">[6]</span>;<br />    UINT8   number_addresses;<br />    UINT8   load_address_l;<br />    UINT8   load_address_h;<br />    UINT8   end_address_l;<br />    UINT8   end_address_h;<br />    UINT8   execution_address_l;<br />    UINT8   execution_address_h;<br />    UINT8   pad<span class="hljs-attr_selector">[128-2-2-2-1-16]</span>;<br />};</code></pre> <p>A .KCC file can be loaded into MESS using the <strong>-quik</strong> command line arg, e.g.:</p>   <pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-subst">&gt;</span><span class="hljs-built_in">.</span>/mess64 kc85_3 <span class="hljs-attribute">-quik</span> test<span class="hljs-built_in">.</span>kcc <span class="hljs-attribute">-rompath</span> <span class="hljs-built_in">.</span> <span class="hljs-attribute">-window</span> <span class="hljs-attribute">-resolution</span> <span class="hljs-number">640</span>x512</code></pre> <p>So if we had a piece of KC85/3 compatible machine code, and put it into a file with a 128-byte KCC header in front, we should be able to load this into the emulator.</p> <p>The canonical ‘Hello World’ program for the KC85/3 looks like this in Z80 machine code:</p> <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-number">0</span>x7F <span class="hljs-number">0</span>x7F <span class="hljs-string">'HELLO'</span> <span class="hljs-number">0</span>x01<br /><span class="hljs-number">0</span>xCD <span class="hljs-number">0</span>x03 <span class="hljs-number">0</span>xF0 <br /><span class="hljs-number">0</span>x23<br /><span class="hljs-string">'Hello World\n\r'</span> <span class="hljs-number">0</span>x00<br /><span class="hljs-number">0</span>xC9</code></pre> <p>That’s a complete ‘Hello World’ in 27 bytes! Put these bytes somewhere in the KC85’s RAM, and after executing the command ‘MENU’ a new menu entry will show up named ‘HELLO’. To execute the program, type ‘HELLO’ and hit Enter: <br><img src="https://lh4.googleusercontent.com/-0qzti5M-Mts/VF_poi-yNbI/AAAAAAAAAac/4QkQDdPODn0/s0/kc85_hello.png" alt="enter image description here" title="kc85_hello.png"></p> <p>How does this magic work? At the start is a special ‘7F 7F’ header which identifies these 27 bytes as a command line program called ‘HELLO’:</p> <pre class="prettyprint"><code class=" hljs bash"><span class="hljs-number">0</span>x7F <span class="hljs-number">0</span>x7F <span class="hljs-string">'HELLO'</span> <span class="hljs-number">0</span>x01</code></pre> <p>Execution starts right after the 0x01 byte:</p> <pre class="prettyprint"><code class=" hljs ">0xCD 0x03 0xF0 <br />0x23</code></pre> <p>The <strong>CD</strong> is the machine code of the Z80 subroutine-call instruction, followed by the call-target address <strong>0xF003</strong> (the Z80 is little-endian, like the x86), this is a call to a central operating system ‘jump vector’, the <strong>0x23</strong> identifies the operating system function, in this case the function is <strong>OSTR</strong> for ‘Output STRing’ (<a href="http://www.mpm-kc85.de/dokupack/KC85_3_uebersicht.pdf">see page 43 of the system manual</a>). This function outputs a string to the current cursor position. The string is not provided as a pointer, but directly embedded into the code after the call and terminated with a zero byte:</p> <pre class="prettyprint"><code class=" hljs tex">'Hello World<span class="hljs-command">\n</span><span class="hljs-command">\r</span>' 0x00</code></pre> <p>After the operating system function has executed, it will resume execution after the string’s 0-terminator byte.</p> <p>The final <strong>C9</strong> byte is the Z80 RETurn statement, which will give control back to the operating system.</p> <p>This was the point where I started to write a bit of Python code which take a chunk of Z80 code, puts a KCC header in front and writes it to a .kcc file. And indeed the MESS loader accepted such a self-made ‘executable’ without problems.</p> <h3 id="mnemonics">Mnemonics</h3> <p>Before tackling the C programming challenge I decided to start smaller, with Z80 assembly code. The SDCC compiler comes (among others) with a Z80 assembler, but I found this hard to use (for instance, it generates intermediate ASCII <a href="http://en.wikipedia.org/wiki/Intel_HEX">Intel HEX</a> files instead of raw binary files).</p> <p>After some more googling I found <a href="http://www.nongnu.org/z80asm/">z80asm</a> which looked solid and easy to use. Again this can be installed via brew:</p> <pre class="prettyprint"><code class=" hljs markdown"><span class="hljs-blockquote">&gt; brew install z80asm</span></code></pre> <p>The simple Hello World machine code blob from above looks like this in Z80 assembly mnemonics:</p> <pre class="prettyprint"><code class=" hljs sql">    org 0x200 ; <span class="hljs-operator"><span class="hljs-keyword">start</span> <span class="hljs-keyword">at</span> address <span class="hljs-number">0x200</span><br />    db <span class="hljs-number">0x7F</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-string">"HELLO"</span>,<span class="hljs-number">1</span> <br />    <span class="hljs-keyword">call</span> <span class="hljs-number">0xF003</span><br />    db <span class="hljs-number">0x23</span><br />    db <span class="hljs-string">"Hello World\r\n\0"</span><br />    ret</span></code></pre> <p>Much easier to read right? And even with comments! Running this file through z80asm yields a binary files with the exact same 27 bytes as the hand-crafted machine code version:</p> <pre class="prettyprint"><code class=" hljs cpp">&gt; z80asm hello.s -o hello.bin<br />&gt; hexdump hello.bin<br /><span class="hljs-number">0000000</span> <span class="hljs-number">7f</span> <span class="hljs-number">7f</span> <span class="hljs-number">48</span> <span class="hljs-number">45</span> <span class="hljs-number">4</span>c <span class="hljs-number">4</span>c <span class="hljs-number">4f</span> <span class="hljs-number">01</span> cd <span class="hljs-number">03</span> f0 <span class="hljs-number">23</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c<br /><span class="hljs-number">0000010</span> <span class="hljs-number">6f</span> <span class="hljs-number">20</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">0</span>d <span class="hljs-number">0</span>a <span class="hljs-number">00</span> c9               <br /><span class="hljs-number">000001</span>b</code></pre> <p>With some more Python plumbing I was then able to ‘cross-assemble’ new programs for the KC85 in a modern development environment. Very cool!</p> <h3 id="c99">C99</h3> <p>But the real challenge remains: compiling and running C code! Compiling a C source through SDCC generates a lot of output files, but none of them is the expected binary blob of executable code:</p> <pre class="prettyprint"><code class=" hljs avrasm">&gt; sdcc hello<span class="hljs-preprocessor">.c</span> <br />&gt; ls<br />hello<span class="hljs-preprocessor">.asm</span>   hello<span class="hljs-preprocessor">.ihx</span>   hello<span class="hljs-preprocessor">.lst</span>   hello<span class="hljs-preprocessor">.mem</span>   hello<span class="hljs-preprocessor">.rst</span><br />hello<span class="hljs-preprocessor">.c</span>     hello<span class="hljs-preprocessor">.lk</span>    hello<span class="hljs-preprocessor">.map</span>   hello<span class="hljs-preprocessor">.rel</span>   hello<span class="hljs-preprocessor">.sym</span></code></pre> <p>There’s 2 interesting files: <strong>hello.asm</strong> is a human-readable assembler source file, and <strong>hello.ihx</strong> is the final executable, but in Intel HEX format. The .ihx file can be converted into a raw binary blob using the <strong>makebin</strong> program also coming with SDCC.</p> <p>But even with a very simple C program there’s already a few things off: <br>    - global variables are placed at address 0x8000 (32kBytes into the address space), on the KC85/3 this is video memory so the default address for data wouldn’t work <br>    - if any global variables are initialized, then the resulting binary file is also at least 32 kBytes big, and has a lot of empty space inside <br>    - there’s a few dozen bytes of runtime initialization code which isn’t needed in the KC85 environment (at least as long as we don’t want to use the C runtime)</p> <p>Thankfully SDCC allows to tweak all this and allows to compile (and link) pieces of C code into raw blobs of machine code without any ‘runtime overhead’, it doesn’t even need a main function to produce a valid executable. </p> <p>Currently I’m placing global data at address 0x200, and code at address 0x300 (so there’s 256 bytes for global data), and I’m disabling anything C-runtime related. And of course we need to tell the compiler to generate Z80 code, these are the important command line options for sdcc:</p> <pre class="prettyprint"><code class=" hljs haml">-<span class="ruby">mz8<span class="hljs-number">0</span><br /></span>-<span class="ruby">-no-std-crt<span class="hljs-number">0</span> --nostdinc --nostdlib<br /></span>-<span class="ruby">-code-loc <span class="hljs-number">0x300</span><br /></span>-<span class="ruby">-data-loc <span class="hljs-number">0x200</span></span></code></pre> <p>With these compiler settings I’m getting the bare-bones Z80 code I want on the KC85. All that’s left now is some macros and system call wrapper functions to provide a KC-style runtime enviornment, and TADAA:</p> <p>C99 programming on a 30 year old 8-bit home computer :D</p> <iframe width="560" height="315" src="//floooh.github.io/kc85sdk/kc85_c.webm" allowfullscreen=""></iframe> <p>Here’s the github link to the ‘kc85sdk’ (work in progress):</p> <p><a href="https://github.com/floooh/kc85sdk">https://github.com/floooh/kc85sdk</a></p> <blockquote>  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>