---
layout: post
title: 'emscripten and PNaCl: App entry in PNaCl'
date: '2013-09-07T16:12:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2013-09-07T16:16:16.306+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-8841203905039391842
blogger_orig_url: http://flohofwoe.blogspot.com/2013/09/emscripten-and-pnacl-app-entry-in-pnacl.html
---

<p>The is the followup to last week's post about <a href="http://flohofwoe.blogspot.de/2013/09/emscripten-and-pnacl-app-entry-in.html">application entry in emscripten</a>. If you haven't done yet I would recommend reading this first before continuing.</p> <p>2 main points to keep in mind about the (P)NaCl platform:</p> <ol><li>Blocking the main thread will block the entire browser tab.</li><li>NaCl has true threading support which can be used to workaround these blocking limitations.</li></ol> <p>Point (1) is the same as on the emscripten platform, and point (2) is the big difference to emscripten.</p> <p>In a Nebula3/PNaCl application, the main function looks the same as on any other platform (I'm using emscripten's "simulate_infinite_loop" approach now):</p> <pre><code>#include "myapplication.h"<br /><br />ImplementNebulaApplication();<br /><br />void<br />NebulaMain(const Util::CommandLineArgs&amp; args)<br />{<br />    MyApplication app;<br />    app.SetCommandLineArgs(args);<br />    app.StartMainLoop();<br />}<br /></code></pre> <p>However under the hood, the startup process until the NebulaMain() function is entered is completely different from other platforms, since <strong>PNaCl doesn't have a main() function</strong>. Instead PNaCl has the concept of application <strong>Module</strong> and <strong>Instance</strong> objects. This is where the plugin-nature of a PNaCl app shines through. There is a single Module object created on a web page containing a PNaCl app, and for each <code>&lt;embed&gt;</code> element on the page, one Instance object. In reality though, most of the time there will be exactly one Module and one Instance object, so the distinction doesn't really matter.</p> <p>PNaCl offers two different startup APIs for C and C++. The C++ API is easier to grasp IMHO, so I'll just concentrate on this (this dual C/C++ nature continues through the whole NaCl API, there's a pure C API, extended by a slightly higher-level C++ API. </p> <p>Hooking up your code to NaCl basically means to write 2 subclasses, one deriving from <strong>pp::Module</strong>, and one deriving from <strong>pp::Instance</strong>, and the NaCl runtime will then call into these classes through virtual methods for initialisation and notifying the application about events.</p> <p>But first things first: </p> <p>Everything starts at a global C Function called <strong>pp::CreateModule()</strong> which you must provide, and which must return a new object of your pp::Module subclass (called <strong>N3NaclModule</strong> in this case):</p> <pre><code>namespace pp<br />{<br />    Module* CreateModule()<br />    {<br />        return new N3NaclModule();<br />    };<br />}<br /></code></pre> <p>Although this is the very first function that NaCl will call, you should be aware that initialisers in the global scope (static objects) will already be initialised and have had their constructors called at this point.</p> <p>The main job of the derived Module class is to create Instance objects, but we can also put some one-time init code in there. There's a pair of functions to initialise and shutdown GL rendering called <strong>glInitializePPAPI()</strong> and <strong>glTerminatePPAPI()</strong>. The only rule is that no GL calls must be made outside these two functions, so I guess we could also put them somewhere else, as long as is guaranteed that they are not called multiple times.</p> <p>But - the most important method in the derived Module class is the factory method for Instance objects called <strong>CreateInstance</strong>. In my case, I have created a subclass of pp::Instance called <strong>NACL::NACLBridge</strong>.</p> <p>The entire N3NaclModule class looks like this:</p> <pre><code>class N3NaclModule : public pp::Module<br />{<br />public:<br />    virtual ~N3NaclModule()<br />    {<br />        glTerminatePPAPI();<br />    }<br />    virtual bool Init()<br />    {<br />        return glInitializePPAPI(get_browser_interface()) == 1;<br />    }<br />    virtual pp::Instance* CreateInstance(PP_Instance instance)<br />    {<br />        return new NACL::NACLBridge(instance);<br />    };<br />};<br /></code></pre> <p>All the really interesting stuff from here on happens in the NACLBrigde object.</p> <p>These two source snippets live inside the ImplementNebulaApplication() macro which all in all looks like this:</p> <pre><code>...<br />#elif __NACL__<br />#define ImplementNebulaApplication() \<br />class N3NaclModule : public pp::Module \<br />{ \<br />public: \<br />    virtual ~N3NaclModule() \<br />    { \<br />        glTerminatePPAPI(); \<br />    } \<br />    virtual bool Init() \<br />    { \<br />        return glInitializePPAPI(get_browser_interface()) == 1; \<br />    } \<br />    virtual pp::Instance* CreateInstance(PP_Instance instance) \<br />    { \<br />        return new NACL::NACLBridge(instance); \<br />    }; \<br />}; \<br />namespace pp \<br />{ \<br />    Module* CreateModule() \<br />    { \<br />        return new N3NaclModule(); \<br />    }; \<br />}<br />#elif __MACOS__<br />...<br /></code></pre> <p>Now on to the NACLBridge class, this is (I know I'm repeating myself) derived from the pp::Instance class, but is called "Bridge" for a reason: in the PNaCl we're spawning a dedicated thread for the game loop, and leave the main thread (aka the Pepper thread) for event handling and rendering. Our derived pp::Instance subclass serves as a "bridge" between these 2 threads, that's why it's called <strong>NACLBridge</strong>.</p> <p>The NaCl runtime will call into virtual methods of an pp::Instance object for handling events, the most important of these are <strong>Init(), DidChangeView(), HandleInputEvent()</strong>. For a complete overview and exhaustive documentation of those callback methods I recommend sifting directly through the SDK header: <strong>include/ppapi/cpp/instance.h</strong></p> <p>In the Init() method I'm only building a CommandLineArgs object from the provided raw arguments (these have been extracted from our <code>&lt;embed&gt;</code> element in the HTML page).</p> <p>The actual initialisation work happens (in my case) in the first call to <strong>DidChangeView()</strong> by calling a Setup() method in the NACLBridge object. I choose this place because this is where I'm getting the current display dimensions of the <code>&lt;embed&gt;</code> element, which is required for the renderer initialisation (although now thinking about it, I might also be able to extract these from the arguments provided in the Init() method, need to try this out some time). </p> <p>The <strong>NACLBridge::Setup()</strong> method only does one thing: create a thread with the <strong>NebulaMain()</strong> function as entry point, and then return to the NaCl runtime. The code inside NebulaMain() works just as on any other platform, with the only difference that it is not running on the main thread, but in its own dedicated game thread.</p> <p>The big advantage to run the game loop in its own thread is that you "own the game loop", and you can perform blocking, for instance to wait for IO. The disadvantage is that you can't call any PPAPI (NaCl system functions) from the game thread, which is a blog-post-topic on its own.</p> <p>So to recap: The <strong>ImplementNebulaApplication</strong> macro runs on the main thread, and creates one <strong>pp::Module</strong> and one <strong>pp::Instance</strong> object. The <strong>pp::Instance</strong> object creates the dedicated game thread, which calls into the <strong>NebulaMain()</strong> function, which from that moment on runs the game loop like on any other platform. With this approach we don't need to slice the game loop into frames like on the emscripten platform.</p> <p>Now that you heroically worked your way through through all of this I'll tell you a secret: NaCl also provides a simple alternative to this complicated mess called the <strong>ppapi_simple</strong> library, which essentially provides a classic main() function running in its own thread, and because blocking is allowed on this thread, also provides normal POSIX fopen()/fclose() style blocking IO functions (sound familiar?). </p> <p>Check out the header file <strong>include/ppapi_simple/ps.h</strong> as starting point.</p> <p>Unfortunately this ppapi_simple library didn't exist when I started dabbling with NaCl about 2 years ago, certainly would have made life a lot easier. On the other hand, the work that had already gone into the NaCl port made the emscripten port easier, which wouldn't be the case had I used the ppapi_simple wrapper code. </p> <blockquote>  <p>Written with <a href="http://benweet.github.io/stackedit/">StackEdit</a>.</p></blockquote>