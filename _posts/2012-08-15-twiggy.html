---
layout: post
title: Twiggy
date: '2012-08-15T20:53:00.002+01:00'
author: Andre Weissflog
tags: 
modified_time: '2012-08-15T21:01:02.536+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-1266650961721714096
blogger_orig_url: http://flohofwoe.blogspot.com/2012/08/twiggy.html
---

I'm currently playing around with some ideas for a new rendering pipeline in Nebula3, strictly experimental stuff, based on the experience so far with <a href="http://www.drakensangonline.com/">Drakensang Online</a>. I'll call it Twiggy because it's so damn slim :)<br /><br />The driving force is that my focus has moved away from consoles towards more "interesting" and especially more open platforms in the past 2 years, namely the web, mobile, and desktop platforms with some sort of built-in app-shop (or good old Steam for that matter). <br /><br />The way-of-thought towards the "grand vision" is basically:<br /><ul><li>&nbsp;Selling software in stores on clunky silver disks is sooo last century...</li><li>Downloading and installing a complete game for half-an-hour or more before being able to play is not much better (it happens that I'm forgetting about half of the demos I'm starting to download on my 360 until I'm deleting them at some later time because I need to make room for new demos, which I will never play as well, ...)</li><li>Regardless of platform (web, mobile, or app-shops on desktop platforms) the experience should be true "click and play". Click a button, and start to play a few seconds later without the player wanting to start another activity in the meantime.</li><li>This means a small initial download of a few megabytes (5..20 MB or so), and from then on it's all about: </li></ul><b>How much new data can we present to the user per second?</b><br /><br />Let's be optimistic and assume somewhere between 2 and 12 Mbit/sec for the civilized areas of the world...<b> </b><br /><br />This means the asset data which is streamed into the game still must be small. It's no longer about how much data fits on a DVD or on Bluray, we can store as much data as we want on web servers. It's all about how fast the user eats through the data while playing the game and how this compares to the available bandwidth. Which is why data compression, sharing and reuse is so important today and the size of a Bluray disc which Sony hyped so much a few years back has become irrelevant.<br /><br />It's a good thing if the game world is built from many small, similar building blocks which can be recombined as much as possible (of course without having an obviously repetitive game world). This is something which works very, very well in Drakensang Online.<br /><br />With all those thoughts and the experience from the current rendering architecture (what works well and what doesn't), here are some starting points of what Twiggy will be:<br /><ul><li>It will initially be built on OpenGL instead of D3D, since the majority of target platforms has some flavour of OpenGL as rendering API.</li><li>The feature base-line will be OpenGL ES 2.0</li><li>The performance base-line will probably be an iPad2</li><li>BUT: it should scale up with additional features, and especially additional fillrate on more powerful target platforms (up to desktop GPUs)</li><li>GPU performance is much more important then CPU performance. Some potential target platforms (like Adobe Alchemy 2) will cross-compile C++ to some VM byte code, while providing full access to the GPUs power. It's important that a game runs smooth even with such a limited "software CPU".</li><li>Optimized for rendering scenes built from an extremely high number of simple 3D objects (that's where the data size savings mainly come from)</li><li>Ditch the "fat render thread" in favour of a very slim render thread behind a simple push buffer. The fat-render-thread design in Nebula3 works, but it is complex. It needs to run in lock-step with the main-thread, needs to transfer data back to the main-thread, and has a lot of redundant code on the render-thread and main-thread side. That's a bit too much hassle for the advantages this design provides.</li><li>More orthogonality throughout the render pipeline: for instance hardware-instancing should be usable with less restrictions (currently, only simple, static 3D objects can be hardware-instanced), make skinned characters and "normal" 3D objects more alike and share more features between them (e.g. using the powerful character animation system for everything, not just characters).</li></ul>The way there is long, since this is a weekend-project, and I will happily throw away and rewrite large chunks of code if they don't feel right. The first step will be the new CoreGraphics2 and Resource2 subsystems, which will implement the new slim render thread, and a resource management system which is more powerful then the current one, yet with much less and simpler code. More on that later. <br /><br />