---
layout: post
title: N3’s Game Database Structure
date: '2009-02-21T14:34:00.002+01:00'
author: Andre Weissflog
tags:
- Nebula3
modified_time: '2009-02-21T15:19:22.064+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-3201187180847297586
blogger_orig_url: http://flohofwoe.blogspot.com/2009/02/n3s-game-database-structure.html
---

<p>Here’s some info on the game database structure used by N3 and N2’s Mangalore, which might be helpful for level editor tools.</p>  <p>“Game data” basically means “everything except graphics, audio or movie stuff”.</p>  <p>All Nebula game-data lives in 2 SQLite database files:</p>  <ul>   <li><strong>home:export/db/static.db4:</strong> This contains all “static” data which doesn’t change over the course of a game session.</li>    <li><strong>home:export/db/game.db4:</strong> This contains all the data which may change during a game session.</li> </ul>  <p>Those files can be inspected and modified with the <a href="http://www.google.de/search?q=SQLiteSpy" target="_blank">SQLiteSpy</a> tool, but since some of the contained data are blobs it may be a good idea to access them with custom tools (N3’s db addon offers wrapper classes for this, but of course it’s also possible to use sqlite directly to access the database).</p>  <p>Both database files are normally populated by various exporter tools in our inhouse-asset-pipeline. </p>  <p>The game.db4 file is important for N3’s standardized <strong>NewGame/Continue/Save/Load</strong> feature:</p>  <ul>   <li>on <strong>New Game</strong>, game.db4 will be copied to the user: directory of the application, changes during game play will be committed back to this copy (usually when a level is left)</li>    <li>on <strong>Continue Game</strong>, N3 will simply open the existing game.db4 file under “user:”</li>    <li>on <strong>Save Game</strong>, a copy of the game.db4 file under “user:” will be performed into the save-game directory</li>    <li>on <strong>Load Game</strong>, the game.db4 in “user:” will be overwritten with a copy from the save-game directory</li> </ul>  <p>The main chunk of data in both database files are game entity related. A game entity is completely described by a collection of key/value pairs called attributes, which live in a single row of a database table.</p>  <p>Application layer subsystems may store additional data in the database by managing their own tables in both databases. Usually, save-game relevant data lives in the game.db4 database, while read-only data lives in the static.db4 database file. Those custom-tables are usually read/written by derived Manager::OnLoad() and Manager::OnSave() methods.</p>  <p>The <strong>static.db4</strong> database contains at least the following tables:</p>  <ul>   <li><strong>_Attributes:</strong> This table contains a description of all attribute types used in other database tables. This lets an application load a database in a meaningful way even if the attributes haven’t been defined in its C++ code. The columns of _Attribute are:</li>    <ul>     <li><strong>AttrName (string, primary, unique, indexed):</strong> the attributes name, doh</li>      <li><strong>AttrType (string):</strong> the type of the attribute, this is how the different types are stored in the database:</li>      <ul>       <li><strong>int:</strong> stored as SQL type INTEGER</li>        <li><strong>bool:</strong> stored as SQL type INTEGER</li>        <li><strong>float:</strong> stored as SQL type REAL</li>        <li><strong>string: </strong>stored as SQL type TEXT</li>        <li><strong>vector3: </strong>a float[3] stored as SQL type BLOB </li>        <li><strong>vector4: </strong>a float[4] stored as SQL type BLOB (a raw Math::float4 written to the database)</li>        <li><strong>matrix44: </strong>a float[16] stored as SQL type BLOB (a raw Math::matrix44 written to the database)</li>        <li><strong>guid: </strong>a ubyte[16] stored as SQL type BLOB (result of Util::Guid::AsBinary())</li>        <li><strong>blob:</strong> can be used to efficiently store “anything else” in the database, hardly used though, Drakensang uses this to store the fog-of-war data for instance</li>     </ul>      <li><strong>AttrReadWrite (bool), AttrDynamic (bool):</strong> these two columns are currently not used in any meaningful way</li>   </ul>    <li><strong>_Categories:</strong> Contains a description of every entity category which shows up in the database. This is basically the lookup-table for the CategoryManager. The _Categories table has the following columns:</li>    <ul>     <li><strong>CategoryName (string, primary, unique, indexed): </strong>The name of the category (e.g. Camera, NPC, Actor, Monster, etc…). Some category names are hard-coded and standardized across games:</li>      <ul>       <li><strong>Light:</strong> describes level light sources</li>        <li><strong>_Environment: </strong>describes “environment objects”, these are simple graphics objects which don’t have game-play functionality</li>        <li><strong>Levels:</strong> a meta-table which contains one row for every level in the game</li>     </ul>      <li><strong>IsVirtualCategory (bool, indexed):</strong> a virtual category only has a ‘template table’ but no ‘instance table’, virtual categories can be used to provide read-only data (lookup tables, etc) to the game application without having to write a custom exporter tool</li>      <li><strong>IsSpecialCategory (bool, indexed): </strong>only the above mentioned hard-coded categories are marked as “special”</li>      <li><strong>CategoryTemplateTable (string):</strong> The name of the database table with entity templates, a template table contains “blueprints” for entities with their initial attribute values. The method FactoryManager::CreateEntityByTemplate() is used to instantiate a new entity from such a template. Template tables live in the static.db4 database.</li>      <li><strong>CategoryInstanceTable (string):</strong> The name of the instance table (only if this is not a virtual category). Instance tables live in the game.db4 database file and contain one row per actual game entity. </li>   </ul>    <li><strong>Template tables: </strong>Template tables contain blueprint for entities which are created through the FactoryManager::CreateEntityByTemplate() method. A row in the template table contains the starting attribute values for a new entity of that type. A template table must contain at least the <strong>Id</strong> column, which must be <strong>(string, primary, unique, indexed)</strong>.</li> </ul>  <p>The <strong>game.db4</strong> database has the following tables:</p>  <ul>   <li><strong>_Attributes: </strong>this has the exact same structure as the _Attributes table in static.db4</li>    <li><strong>_Globals:</strong> this is a simple global variable storage managed by the <strong>GlobalAttrsManager</strong>. </li>    <li><strong>Instance tables: </strong>the instance tables as listed in the _Categories table of static.db4. Every game entity in the entire game has a row in one of the instance tables. The general structure of an instance table is the same as the associated template table, but with the following additional columns:</li>    <ul>     <li><strong>Guid (guid, primary, unique, indexed): </strong>a unique identifier for the entity</li>      <li><strong>_ID (string): </strong>a human-readable unique identifier (only within the level)</li>      <li><strong>_Level (string, indexed): </strong>the level where this entity currently resides (may change during game)</li>      <li><strong>_Layers (string):</strong> The layers this entity is a member of. Entity layers can be used to “overlay” a specific group of entities at level load time. This can be used for day/night, intact/destroyed versions of a level without duplicating the entire level. An empty _Layers attribute means that this entity is always loaded into a level.</li>      <li><strong>Transform (matrix44):</strong> the current world space transform of the entity</li>   </ul> </ul>  <p>The <strong>_Instance_Levels</strong> instance table is special in that it doesn’t have the above mentioned hardcoded attributes. Instead it contains one row per level in the game with the following attributes:</p>  <ul>   <li><strong>Id (string, primary, unique, indexed):</strong> a unique-id string of the level</li>    <li><strong>Name (string, indexed):</strong> the human-readable name of the level</li>    <li><strong>StartLevel (bool):</strong> true if this is the start level which should be loaded on New Game, false for all other levels</li>    <li><strong>_Layers (string):</strong> the currently active entity layers</li>    <li><strong>Center (vector3):</strong> the midpoint of the level in world space</li>    <li><strong>Extents (vector3):</strong> the extents vector of the level (Center and Extents are used to describe the bounding box of the level)</li>    <li><strong>NavMesh, NavMeshTransform, NoGoArea, NoGoAreaTransform: </strong>used by the navigation subsystem (not currently implemented in Nebula3)</li> </ul>  <p>Most entity-related database accesses are wrapped by the CategoryManager, which currently caches most of the data in memory (all template tables, and all entity instance data of the current level). This may change in the future when we generally run SQLite through the in-memory mode. If the in-memory database accesses are fast enough we might drop the caching (which isn’t as good as I’d like because of the huge amount of memory allocations going on during reading from the database).</p>