---
layout: post
title: Nebula3's Multithreaded Rendering Architecture
date: '2008-03-05T12:03:00.002+01:00'
author: Andre Weissflog
tags:
- Nebula
modified_time: '2008-03-06T11:57:05.744+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-1217510401325801990
blogger_orig_url: http://flohofwoe.blogspot.com/2008/03/alright-application-layer-is-now.html
---

Alright! The Application Layer is now running through the new multithreaded rendering pipeline.<br /><br />Here's how it works:<br /><br /><ul><li>The former Graphics subsystem has been renamed to InternalGraphics and is now running in its own "fat thread" with all the required lower-level Nebula3 subsystems required for rendering.</li><li>There's a new Graphics subsystem running in the application thread with a set of proxy classes which mimic the InternalGraphics subsystem classes.</li><li>The main thread is now missing any rendering related subsystems, so trying to call e.g. RenderDevice::Instance() will result in a runtime error.</li><li>Extra care has been taken to make the overall design as simple and "fool-proof" as possible.</li><li>There's very little communication necessary between the main and render threads. Usually one SetTransform message for each graphics entity which has changed its position.<br /></li><li>Communication is done with standard Nebula3 messages through a single message queue in the new GraphicsInterface singleton. This is an "interface singleton" which is visible from all threads. The render thread receives messages from the main thread (or other threads) and never actively sends messages to other threads (with one notable exception on the Windows platform: mouse and keyboard input).</li><li>Client-side code doesn't have to deal with creating and sending messages, because it talks through proxy objects with the render thread. Proxy objects provide a typical C++ interface and since there's a 1:1 relationship may cache data on the client-side to prevent a round-trip into the render thread (so there's some data duplication, but a lot less locking)</li><li>The Graphics subsystem offers the following public proxy classes at the moment:</li><ul><li><b>Graphics::Display:</b> setup and query display properties</li><li><b>Graphics::GraphicsServer: </b>creates and manages Stages and Views</li><li><b>Graphics::Stage:</b> a container for graphics entities</li><li><b>Graphics::View: </b>renders a "view" into a Stage into a RenderTarget</li><li><b>Graphics::CameraEntity: </b>defines a view volume</li><li><b>Graphics::ModelEntity: </b>a typical graphics object</li><li><b>Graphics::GlobalLightEntity: </b>a global, directional light source</li><li><b>Graphics::SpotLightEntity:</b> a local spot light</li></ul><li>These proxy classes are just pretty interfaces and don't do much more then creating and sending messages into the GraphicsInterface singleton.</li><li>There are typically 3 types of messages sent into the render thread:</li><ol><li>Synchronous messages which block the caller thread until they are processed, this is just for convenience and only exists for methods which are usually not called while the main game loop is running (like Display::GetAvailableDisplayModes())</li><li>Asynchronous messages which return immediately but pass a return-value back at some later time. These are non-blocking, but the result will only be available in the next graphics frame. The proxy classes do everything possible to hide this fact by either caching values on the client side, so that no communication is necessary at all, or by returning the previous value until the graphics thread gets around to process the message).<br /></li><li>The best and most simple messages are those which don't require a return value. They are just send off by the client-side proxy and processed at some later time by the render thread. Fortunately, most messages sent during a frame are of this nature (e.g. updating entity transforms).</li></ol><li>Creation of Graphics entities is an asynchronous operation, it is possible to manipulate the client-side proxy object immediately after creation even though the server-side entity doesn't exist yet. The proxy classes take care about all these details internally.</li><li>There is a single synchronization event per game-frame where the game thread waits for the graphics thread. This event is signalled by the graphics thread after it has processed pending messages for the current frame and before culling and rendering. This is necessary to prevent the game thread from running faster then the render thread and thus spamming its message queue. The game thread may run at a lower - but never at a higher - frame rate as the render thread.</li></ul><br />Here's some example code from the testviewer application. It actually looks simpler then before since all the setup code has become much tighter:<br /><blockquote><span style="color:#073763;"><span style="color:#0c343d;"> <span style="color:#0b5394;">       using namespace Graphics;<br />       using namespace Resources;<br />       using namespace Util;<br /><br />       <span style="color:#274e13;">// setup the render thread</span></span></span></span><br /><span style="color:#073763;"><span style="color:#0c343d;"><span style="color:#0b5394;">        Ptr&lt;GraphicsInterface&gt; graphicsInterface = GraphicsInterface::Create();</span></span></span><br /><span style="color:#073763;"><span style="color:#0c343d;"><span style="color:#0b5394;">        graphicsInterface-&gt;Open();</span></span></span><br /><br /><span style="color:#073763;"><span style="color:#0c343d;"><span style="color:#0b5394;">       <span style="color:#274e13;"> // setup and open the display</span></span></span></span><br /><span style="color:#073763;"><span style="color:#0c343d;"><span style="color:#0b5394;">        Ptr&lt;Display&gt; display = Display::Create();</span></span></span><br /><span style="color:#073763;"><span style="color:#0c343d;"><span style="color:#0b5394;">        // ... optionally change display settings here...</span></span></span><br /><span style="color:#073763;"><span style="color:#0c343d;"><span style="color:#0b5394;">        display-&gt;Open();</span></span></span><br /></blockquote><span style="color:#073763;"><br /><span style="color:#000000;">That's all that is necessary to open a default display and get the render thread up and running. The render thread will now happily run its own render loop.<br /><br />To actually have something rendered we need at least a Stage, a View, a camera, at least one light and a model:<br /><span style="color:#0b5394;"><br /></span></span></span><blockquote><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;">        <span style="color:#274e13;">// create a GraphicServer, Stage and a default View</span></span></span></span><br /><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;">        Ptr&lt;GraphicsServer&gt; graphicsServer = GraphicsServer::Create();</span></span></span><br /><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;">        graphicsServer-&gt;Open();</span></span></span><br /><br /><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;">        Attr::AttributeContainer dummyStageBuilderAttrs;</span></span></span><br /><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;">        Ptr&lt;Stage&gt; stage = graphicsServer-&gt;CreateStage(StringAtom("DefaultStage"), </span></span></span><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;"><br />                                                                           Graphics::SimpleStageBuilder::RTTI, </span></span></span><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;"><br />                                                                           dummyStageBuilderAttrs</span></span></span><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;">);<br /><br />       Ptr&lt;View&gt; view = this-&gt;graphicsServer-&gt;CreateView(InternalGraphics::InternalView::RTTI,<br />                                                                              StringAtom("DefaultView"),<br />                                                                              StringAtom("DefaultStage"),<br />                                                                              ResourceId("DX9Default"),<br />                                                                              true);<br /><br /><span style="color:#274e13;">        // create a camera and make it the active camera for our view<br />       <span style="color:#0b5394;">Ptr&lt;CameraEntity&gt; camera = CameraEntity::Create();<br />       camera-&gt;SetTransform(matrix44::translation(0.0f, 0.0f, 10.0f));<br />       stage-&gt;AttachEntity(camera.cast&lt;GraphicsEntity&gt;());<br />       view-&gt;SetCameraEntity(camera);<br /><br /><span style="color:#274e13;">        // create a global light source<br />       <span style="color:#0b5394;">Ptr&lt;GlobalLightEntity&gt; light = GlobalLightEntity::Create();<br />       light-&gt;SetTransform(matrix44::rotationx(n_deg2rad(-70.0f)));<br />       stage-&gt;AttachEntity(light.cast&lt;GraphicsEntity&gt;());<br /><br /><span style="color:#274e13;">        // finally create a visible model<br /><span style="color:#0b5394;">        Ptr&lt;ModelEntity&gt; model = ModelEntity::Create();<br />       model-&gt;SetResourceId(ResourceId("mdl:examples/eagle.n2"));<br />       stage-&gt;AttachEntity(model.cast&lt;GraphicsEntity&gt;());<br /></span></span></span></span></span></span><br /></span></span></span></blockquote><span style="color:#073763;"><span style="color:#000000;"><span style="color:#0b5394;"><span style="color:#000000;">That's the code to setup a simple graphics world in the asynchronous rendering case. There are a few issues I still want to fix (like the InternalGraphics::InternalView::RTTI thing). The only thing that's left is to add a call to GraphicsInterface::WaitForFrameEvent() somewhere into the game-loop before updating the game objects for the next frame. The classes App::RenderApplication and App::ViewerApplication in the Render layer will actually take care of most of this stuff.<br /><br />There's some brain-adaption required to work in an asynchronous rendering environment:<br /><br /></span></span></span></span><ul><li>there's always a delay of up to one graphics frame until a manipulation actually shows up on screen</li><li>it's hard (and inefficient) to get data back from the render thread<br /></li><li>it's impossible for client-threads to read, modify and write-back data within one render-frame</li></ul><br />For the tricky application specific stuff I'm planning to implement some sort of installable client-handlers. Client threads can install their own custom handler objects which would run completely in the render-thread context. This is IMHO the only sensible way to implement application specific graphics functionality which requires exact synchronization with the render-loop.<br /><br />I've had to do a few other changes to the existing code base for the asynchronous rendering to work: Mouse and keyboard events under Windows are produced by the application Windows (which is owned by the render thread), but the input subsystem lives in the game thread. Thus there needs to be a way for the render thread to communicate those input events into the main thread. I decided to derive a ThreadSafeDisplayEventHandler class (and ThreadSafeRenderEventHandler for the sake of completeness). Client threads can install those event handlers to be notified about display and render events coming out of the render-thread.<br /><br />The second, bigger, change affected the Http subsystem. Previously, HttpRequestHandlers had to live in the same thread as the HttpServer, which isn't very useful anymore now that important functionality has been moved out of the main thread. So I basically moved the whole Http subsystem into its own thread as well, and HttpRequestHandlers may now be attached from any thread. There's a nice side effect now that a Http request only stalls the thread of the HttpRequestHandler which processes the request.<br /><br />There's still more work to do:<br /><br /><ul><li>need to write some stress-tests to uncover any thread-synchronization bugs</li><li>need to do performance investigations and profiling (are there any unintended synchronizations issues?)<br /></li><li>thread-specific low-level optimization in the Memory subsystem as detailed in one of my previous posts</li><li>optimize the messaging system as much as possible (especially creation and dispatching)<br /></li><li>I also want to implement some sort of method to run the rendering in the main thread, partly for debugging, partly for platforms with simple single-core CPUs<br /></li></ul><br />Phew, that's all for today :)