---
layout: post
title: 'emscripten and PNaCl: Build Systems'
date: '2013-08-26T22:32:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2013-08-26T22:32:24.508+01:00'
thumbnail: https://lh3.googleusercontent.com/-eUVvEFJ8uOQ/Uhu8CcYCOlI/AAAAAAAAARs/FmG6uiO27Mc/s72-c/Screen+Shot+2013-08-26+at+10.34.10+PM.png
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-8750264385147452404
blogger_orig_url: http://flohofwoe.blogspot.com/2013/08/emscripten-and-pnacl-build-systems.html
---

<p>I recently ported Nebula3 to Google's PNaCl. Main motivation was that I wanted to see how it compares to asm.js both for performance and "ease of use". This was basically a drive-by port, I didn't want to put too much effort into it. Thankfully I had old NaCl code lying around which I could reuse and after 2 or 3 afternoons (and some WTF-moments) I had a pretty clean port running which I'm planning to keep updated into the foreseeable future.</p> <p>The big news about PNaCl is that deployment no longer has to go through the Chrome Web Store, instead it is now finally possible to host PNaCl applications from any URL.</p> <p>You can check out the Nebula3 PNaCl demos here: <a href="http://www.flohofwoe.net/demos.html">http://www.flohofwoe.net/demos.html</a>. Just make sure you're running the latest Google Chrome Canary, and if an error pops up that PNaCl isn't enabled, just restart Chrome, and wait a little bit. First start can take up to one minute, since PNaCl support is installed on demand which is a multi-MByte download.</p> <p>Over the next few weeks I'm intending to write up a little series of blog posts comparing the PNaCl and emscripten Nebula3 ports. From a coder's perspective, the two systems are actually fairly close when seen from high above.</p> <p>As a "pragmatic programmer", I don't really care about the political side. Both asm.js and PNaCl had to take a lot of flak from web purists. The only thing that counts to me is that both technologies provide a seamless software distribution channel directly from the coder to the user. No app shops, gate-keepers, code-signing-certificates or approval processes inbetween.</p> <h4 class="wmd-title" id="the-build-system">The Build System</h4> <p>First step is of course to get the SDKs. Both emscripten and PNaCl offer a GCC-style cross-compiling toolchain based on Clang-LLVM. Quick disclaimer: I'm running on OSX, haven't looked at the Windows side of things yet. </p> <p>The <strong>emscripten SDK</strong> is simply installed and updated through a github repository. There's a stable <strong>master</strong> branch, and a bleeding-edge <strong>incoming</strong> branch. emscripten requires a couple of external tools, most notably Clang-LLVM, python and node.js. Even though clang is the standard compiler on OSX I installed a separate version because emscripten required a newer version then was installed on OSX 10.7. Paths to external tools must be provided through a <strong>.emscripten</strong> config file in your home dir.</p> <p>The NaCl SDK is a normal download-archive which should be unzipped to a nacl_sdk directory in your home directory. This download only contains a script file called "naclsdk" which takes care of downloading and updating the actual SDK files in the future. The NaCl SDK contains versioned bundles, each of which is actually a complete SDK in itself, with tools, headers, libraries and examples. This is the same philosophy as the DirectX SDKs. You pick a version to work with and decide yourself when to switch to a newer version, this guarantees you a stable API, and gives the dev team the freedom to change APIs in new versions without breaking code compiled against older versions.</p> <p>One challenge about the NaCl SDK is to find the right compiler tools and runtime libs since there are so many choices. The "classic" CPU-specific NaCl had different toolchains for ARM and Intel CPU architectures, and two different C runtime libs to choose from: newlib or glibc.</p> <p>PNaCl is much simpler though: there are no longer different target CPU architectures since PNaCl executables are essentially LLVM bitcode, and the only available C runtime lib is newlib (which is the better choice anyway, since it is much slimmer then glibc).</p> <p>In Nebula3 I'm using <strong>cmake</strong> to generate build files for different target platforms and build systems / IDEs. For each platform, you build a so called <strong>toolchain file</strong> which contains paths to the cross-compiling tools, search paths to headers and libraries, and compiler/linker settings.</p> <p>Writing such a toolchain file can be a bit of guess work, but there are examples flying around the net, also emscripten comes with sample cmake toolchain files which might be helpful as a starting point.</p> <p>Here are a couple of tips which might save you a some trouble:</p> <ul><li>don't set "ld" as the linker tool, in both toolchains the normal compiler tool also serves as linker (in emscripten this is <strong>emcc</strong>, in PNaCl use <strong>pnacl-clang++</strong></li><li>PNaCl requires an additional post-build-step after linking, called pnacl-finalize, cmake has the <strong>add_custom_command</strong> macro for this</li></ul> <p>To properly separate the different build files I have a directory structure like this:</p> <pre><code>nebula3/<br />    code/<br />    cmake/<br />        emscripten_asmjs/<br />        emscripten_debug/<br />        pnacl_release/<br />        pnacl_debug/<br /></code></pre> <p>All the source code lives under /code, and all the build files are generated under cmake/ with one directory per target platform and build configuration.</p> <p>To actually generate the build files, I have a couple of shell scripts under /code which invoke cmake like this:</p> <pre><code>cd ../cmake/emscripten_asmjs<br />cmake -G "Eclipse CDT4 - Ninja" -DCMAKE_BUILD_TYPE="AsmJS" -DNEBULA_PLATFORM=EMSCRIPTEN -DCMAKE_TOOLCHAIN_FILE="../../bin/emscripten.toolchain.cmake" ../../code<br /></code></pre> <p>The <strong>-G</strong> option is the cmake "generator", we're telling cmake here that we want Eclipse project files using the ninja build tool (ninja is a more modern make alternative). *-DCMAKE_BUILD_TYPE* sets the AsmJS build config (cmake lets us define any number of custom configs, commonly just Release and Debug but in emscripten I have defined an extra AsmJS config), then -DNEBULA_PLATFORM=EMSCRIPTEN is one of our own custom symbol definitions, this simply tells our cmake files, that we're building for the emscripten target platform (actually this is redundant, a better place for this definition would be the toolchain file). Next we tell cmake which toolchain file to use, and finally where the source code is located (or more specifically: where to find the root CMakeLists.txt file - CMakeLists.txt files tell cmake what targets to build, and from what sources).</p> <p>When cmake has run, we could import the generated project into Eclipse, or we can just run ninja from the command line:</p> <p><img src="https://lh3.googleusercontent.com/-eUVvEFJ8uOQ/Uhu8CcYCOlI/AAAAAAAAARs/FmG6uiO27Mc/s0/Screen+Shot+2013-08-26+at+10.34.10+PM.png" alt="ninja invocation" title="ninja.png"></p> <p>Writing a proper cmake based build environment can be a lot of work, but it is definitely worth it. Managing a multi-platform build environment across Linux, OSX and Windows and probably several game consoles, spanning different IDEs like Visual Studio, Xcode and Eclipse would be a nightmare without a meta-build-tool like cmake.</p> <h3 class="wmd-title" id="deployment">Deployment</h3> <p>Big jump here, but no worries, I'll deal with all the inbetween-stuff in the following blog posts.</p> <p>The common thing between emscripten and PNaCl when deploying is that  the generated files are embedded into a web page, and thus can be easily integrated into existing web site build- and deployment-processes.</p> <p>The details are a little bit different between the two though:</p> <p>An emscripten "executable" is either a .js file or a complete HTML page (the so called shell page) which embeds the generated Javascript code. The emscripten linker looks at the output file extension to decide whether it should generate a .js or .html file. Emscripten comes with a default html shell file which should be used as starting point for a customised web page.</p> <p>Integrating emscripten generated code into a web page is just the same as integrating any piece of complex Javascript code. Since emscripten-generated code is just Javascript, it is also very easy to interact with the rest of the page through direct JS function calls.</p> <p>PNaCl on the other hand integrates like a plugin into the HTML page using the <strong>embed</strong> element:</p> <pre><code>&lt;embed src="dragons.nmf" class="pnacl" id="pnacl_module" name="pnacl_module" width="800" height="452" type="application/x-pnacl"/&gt;<br /></code></pre> <p>Instead of the .pexe file, a .nmf <strong>manifest</strong> file is given to the embed element which contains the name of the .pexe file (this manifest file used to look more interesting in classic NaCl since it contained one entry for each target cpu architecture, but for PNaCl there's only one useful piece of information):</p> <pre><code>{<br />    "program": {<br />        "portable": {<br />            "pnacl-translate": {<br />                "url": "dragons.pexe"<br />            }<br />        }<br />    }<br />}<br /></code></pre> <p>Finally, the <strong>type="application/x-pnacl"</strong> attribute is important for Chrome to recognise the embed element as a PNaCl application.</p> <p>Interaction between a PNaCl application and the surrounding web page works through the Javascript messaging system. To get events from the PNaCl application, just add event listeners to the embed element:</p> <pre><code>&lt;script type="text/javascript"&gt;<br />    // ...<br />    var naclModule = document.getElementById("pnacl_module");<br />    naclModule.addEventListener('loadstart', handleLoadStart, true);<br />    naclModule.addEventListener('progress', handleProgress, true); <br />    naclModule.addEventListener('load', handleLoad, true);<br />    naclModule.addEventListener('error', handleError, true);<br />    naclModule.addEventListener('crash', handleCrash, true);<br />    naclModule.addEventListener('message', handleMessage, true);<br />    // ...<br />&lt;/script&gt;<br /></code></pre> <p>The other way around works as well, by sending messages to the PNaCl app through postMessage.</p><h3 class="wmd-title" id="the-end">The End</h3> <p>Ok, that's it. Next up I'll go through the changes to the Nebula3 Application Model which were necessary for the web platforms!</p> <blockquote>  <p>Written with <a href="http://benweet.github.io/stackedit/">StackEdit</a>.</p></blockquote>