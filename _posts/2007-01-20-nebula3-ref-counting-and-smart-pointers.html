---
layout: post
title: Nebula3 ref-counting and smart pointers.
date: '2007-01-20T15:07:00.000+01:00'
author: Andre Weissflog
tags:
- English
- Nebula
modified_time: '2007-01-20T15:56:41.495+01:00'
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-5723773965272749544
blogger_orig_url: http://flohofwoe.blogspot.com/2007/01/nebula3-ref-counting-and-smart-pointers.html
---

C++ only offers automatic life time management for objects created on the stack. When the C++ context is left, stack objects will be destroyed automatically:<br /><pre><br />{<br />   // create a new object on the stack<br />   MyObject obj;<br /><br />   // do something with obj...<br /><br />   // current context is left, obj is destroyed automatically<br />}<br /></pre><br />When creating an object on the heap, the object has to be destroyed manually, otherwise a memory leak will result:<br /><pre><br />{<br />   // create an object on the heap<br />   MyObject* objPtr = new MyObject;<br /><br />   // do something with obj...<br /><br />   // need to manually destroy obj<br />   delete obj;<br />}<br /></pre><br />This gets all much more complicated, when more then one "client" needs access to a C++ object, because then, ownership rules must be defined (the owner would be responsible for deleting an object, all other clients just "use" the object).<br /><br />In a complex software system, this ownership management gets tricky very quickly. An elegant solution to this problem is refcounting. With refcounting, no ownership must be defined, since each "client" increments a reference count on the target object, and decrements the refcount when it no longer needs to access the object by calling a Release() method. When the refcount reaches zero (meaning, no client accesses the object any more), the object is destroyed. This fixes the multiple client scenario, but still requires the programmer to manually call the Release() method at the right time.<br /><br />Smart pointer fix this second problem as well. A smart pointer is a simple templated C++ object which points to another C++ object, which manages the target refcount on creation, destruction and assignment. Other then that a smart pointer can just be used like a raw pointer, except that it fixes all the dangerous stuff associated with raw pointers.<br /><br />Lets take a look at how the above code would look in Nebula3:<br /><pre><br />{<br />   // create a C++ object on the heap<br />   Ptr&lt MyObject &gt obj = MyObject::Create();<br /><br />   // do something with obj<br />   obj-&gt DoSomething();<br /><br />   // at the end of context, the smart pointer object is destroyed<br />   // and will release its target object<br />}<br /></pre><br />With smart pointers, a heap object handles exactly like a stack object, no extra care is needed for releasing the object at the right time. Smart pointers also fix the cleanup problem with arrays of pointers. If you want to create a dynamic array with raw pointers to heap objects, you must take care to delete the target objects manually before destroying the array, because a raw pointer has no destructor which could be called when the array is destroyed. By creating an array of smart pointers, this problem is solved as well. When the array is released, it will call the destructors of the contained smart pointers, which in turn will release their target objects:<br /><pre><br />{<br />   // create an array of smart pointers<br />   Array&lt Ptr&lt MyObject &gt&gt objArray;<br /><br />   // create objects and append to array<br />   int i;<br />   for (i = 0; i &lt 10; i++)<br />   {<br />       Ptr&lt MyObject &gt = MyObject::Create();<br />       objArray.Append(obj);<br />   }<br />   // when the current context is left, the array is destroyed     <br />   // which destroys all its contained smart pointers, which in turn     <br />   // destroy their target object... <br />} <br /></pre><br />That's it, simple and elegant. With smart pointers you can work with heap objects just as they were stack objects!<br /><br />Refcounting and smart pointers are not perfect however. They fail on cyclic dependencies (when 2 objects point to each other). There seems to be no clean and easy fix to this. Thankfully, in a well-designed software system cyclic dependencies are rarely necessary.