---
layout: post
title: Nebula3 RTTI Tips & Tricks
date: '2009-06-16T08:59:00.001+01:00'
author: Andre Weissflog
tags: 
modified_time: '2009-06-16T08:59:40.620+01:00'
thumbnail: http://lh5.ggpht.com/_cWdorEDEaNg/SjdQ6-U2w5I/AAAAAAAAAIA/b5Mr9Zrtq1I/s72-c/rtti_collision_thumb2.jpg?imgmax=800
blogger_id: tag:blogger.com,1999:blog-2948438400037317662.post-6674488246124032560
blogger_orig_url: http://flohofwoe.blogspot.com/2009/06/nebula3-rtti-tips-tricks.html
---

<p>Note: I have omitted the namespace prefixes and ‘using namespace xxx’ statements in the code below to improve readability. Also, since I didn’t run the code through a compiler, there may be a lot of typos.</p>  <h4>&#160;</h4>  <h4>Don’t be confused by Rtti vs. RTTI:</h4>  <p>Rtti is the class name, MyClass::RTTI is the name of the Rtti-object of a class. Every RefCounted derived class has exactly one static instance of Core::Rtti, which is initialized before main() is entered.</p>  <h4>&#160;</h4>  <h4>Check whether an object is an instance of a specific, or of a derived class:</h4>  <p>This is the standard feature of the Nebula3 RTTI system, checking whether an object can safely be cast to a specific class interface: </p>  <blockquote>   <p><font face="Courier New">// check whether obj is instance of a specific class:        <br />if (obj-&gt;IsInstanceOf(MyClass::RTTI)) …</font></p>    <p><font face="Courier New">// check whether obj is instance of class, or a derived class:        <br />if (obj-&gt;IsA(MyClass::RTTI))…</font></p> </blockquote>  <p>Compared to Nebula2, N3’s RTTI check is extremely fast (in N2, it was necessary to convert a class name string into a pointer first before doing the check). In N3, RTTI checks are simple pointer comparisons. The IsA() method is a bit slower if the class doesn’t match since it needs to walk the inheritance hierarchy towards the root. Because of this it is always better to use the IsInstanceOf() method if possible, since this is always only a single pointer comparison.</p>  <p>Both methods also exist as class-name and class-fourcc versions, but of course these are both slower then the methods which directly work with the RTTI objects:</p>  <blockquote>   <p><font face="Courier New">if (obj-&gt;IsInstanceOf(“MyNamespace::MyClass”)) …        <br />if (obj-&gt;IsInstanceOf(FourCC(‘MYCL’))…</font></p>    <p><font face="Courier New">if (obj-&gt;IsA(“MyNamespace::MyClass”))…        <br />if (obj-&gt;IsA(FourCC(‘MYCL’))…</font></p> </blockquote>  <h4>&#160;</h4>  <h4>Using Ptr&lt;&gt; cast methods for safe-casting:</h4>  <p>The Ptr&lt;&gt; class comes with 3 cast methods, 2 for safe up- and down-casts, and one unsafe-but-fast C-style cast. To do a down-cast (from a general parent class down to a specialized sub-class) you can do this:</p>  <blockquote>   <p><font face="Courier New">// assume that res is a Ptr&lt;Resource&gt;, and safely down-cast        <br />// it to a Ptr&lt;D3D9Texture&gt; (D3D9Texture is a subclass of Resource):         <br />const Ptr&lt;D3D9Texture&gt;&amp; d3d9Tex = res.downcast&lt;D3D9Texture&gt;();</font></p> </blockquote>  <p>This will generate a runtime-error if tex is not a D3D9Texture object.</p>  <p>Safely casting upwards in the inheritance hierarchy works as well:</p>  <blockquote>   <p><font face="Courier New">const Ptr&lt;Resource&gt;&amp; res = d3d9Tex.upcast&lt;Resource&gt;();</font></p> </blockquote>  <p>An unsafe C-style cast is done like this:</p>  <blockquote>   <p><font face="Courier New">const Ptr&lt;Resource&gt;&amp; res = d3d9Tex.cast&lt;Resource&gt;();</font></p> </blockquote>  <p>An unsafe cast is the fastest (in release mode, the compiler should optimize the method call into nothing), but of course it also makes it extremely easy to shoot yourself in the foot. The 2 safe-cast methods call the Rtti::IsDerivedFrom() method, no temporary Ptr&lt;&gt; object will be created since they return a const-ref.</p>  <h4>&#160;</h4>  <h4>Query RTTI objects directly:</h4>  <p>You can directly query many class properties without having an actual object of the class around:</p>  <blockquote>   <p><font face="Courier New">// get the name of a class:        <br />const String&amp; className = MyClass::RTTI.GetName();</font></p>    <p><font face="Courier New">// get the FourCC identifier of aclass:        <br />FourCC classFourCC = MyClass::RTTI.GetFourCC();</font></p>    <p><font face="Courier New">// get a pointer to the Rtti object of the parent class        <br />// (returns 0 when called on RefCounted::RTTI)</font><font face="Courier New">        <br />Rtti* parentRtti = MyClass::RTTI.GetParent();</font></p>    <p><font face="Courier New">// check if a class is derived from this class:        <br />// by Rtti object:</font><font face="Courier New">        <br />if (MyClass::RTTI.IsDerivedFrom(OtherClass::RTTI)) …         <br /></font><font face="Courier New">// by class name:        <br />if (MyClass::RTTI.IsDerivedFrom(“MyNamespace::OtherClass”)) …         <br />// by class fourcc:         <br />if (MyClass::RTTI.IsDerivedFrom(FourCC(‘OTHR’))…</font></p> </blockquote>  <p>You can check two Rtti objects for equality or inequality:</p>  <blockquote>   <p><font face="Courier New">const Rtti&amp; otherRtti = …;        <br />if (MyClass::RTTI == otherRtti)…         <br /></font><font face="Courier New">if (MyClass::RTTI != otherRtti)…</font></p> </blockquote>  <p>Since it is guaranteed that only one Rtti object exists per class this is equivalent with comparing the addresses of 2 Rtti objects (and that’s in fact what the equality and inequality operators do internally). </p>  <h4>&#160;</h4>  <h4>Create objects directly through the RTTI object:</h4>  <blockquote>   <p><font face="Courier New">Ptr&lt;MyClass&gt; myObj = (MyClass*) MyClass::RTTI.Create();</font></p> </blockquote>  <p>The old-school C-style cast looks a bit out of place but is currently necessary because the Rtti::Create() method returns a raw pointer, not a smart-pointer.</p>  <p>Creating an object through the RTTI object instead of the static MyClass::Create() method is useful if you want to hand the type of an object as an argument to a method call like this:</p>  <blockquote>   <p><font face="Courier New">Ptr&lt;RefCounted&gt; CreateObjectOfAnyClass(const Rtti&amp; rtti)        <br />{         <br />&#160;&#160;&#160; return rtti.Create();         <br />}</font></p> </blockquote>  <p>This is a lot faster then the 2 other alternatives, creating the object through its class name or class fourcc identifier.</p>  <p>&#160;</p>  <h4>Create objects by class name or FourCC identifier</h4>  <p>You can use the Core::Factory singleton to create RefCounted-derived objects by class name or by a FourCC identifier:</p>  <blockquote>   <p><font face="Courier New">Ptr&lt;MyClass&gt; obj = (MyClass*) Factory::Instance()-&gt;Create(“MyNamespace::MyClass”);</font></p>    <p><font face="Courier New">Ptr&lt;MyClass&gt; obj = (MyClass*) Factory::Instance()-&gt;Create(FourCC(‘MYCL’));</font></p> </blockquote>  <p>This is mainly useful for serialization code, or if the type of an object must be communicated over a network connection.</p>  <h5><font face="Courier New"><font face="Verdana"></font></font></h5>  <h5><font face="Courier New"><font face="Verdana"></font></font></h5>  <h5><font face="Courier New"><font face="Verdana"></font></font></h5>  <h4><font face="Courier New"><font face="Verdana"></font></font></h4>  <h4><font face="Courier New"><font face="Verdana"></font></font></h4>  <h4><font face="Courier New"><font face="Verdana">Lookup the RTTI object of a class through the Core::Factory singleton</font></font></h4>  <p>You can get a pointer to the static RTTI object of a class by class name or class FourCC identifier:</p>  <blockquote>   <p><font face="Courier New">const Rtti* rtti = Factory::Instance()-&gt;GetClassRtti(“MyNamespace::MyClass”);</font></p>    <p><font face="Courier New">const Rtti* rtti = Factory::Instance()-&gt;GetClassRtti(FourCC(‘MYCL’));</font></p> </blockquote>  <p>This will fail hard if the class doesn’t exist, you can check whether a class has been registered with the factory using the ClassExists() methods:</p>  <blockquote>   <p><font face="Courier New">bool classExists = Factory::Instance()-&gt;ClassExists(“MyNamespace::MyClass”);</font></p>    <p><font face="Courier New">bool classExists = Factory::Instance()-&gt;ClassExists(FourCC(‘MYCL’));</font></p> </blockquote>  <p><font face="Courier New"></font></p>  <h5>&#160;</h5>  <h4>Troubleshooting</h4>  <p>There are 2 common problems with Nebula3’s RTTI system.</p>  <p>When writing a new class, it may happen that the FourCC code of the class is already taken. In this case, an error dialog will popup at application start which looks like this:</p>  <p><a href="http://lh3.ggpht.com/_cWdorEDEaNg/SjdQ6jDlYkI/AAAAAAAAAH8/-3PfGpoQJZk/s1600-h/rtti_collision4.jpg"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="rtti_collision" border="0" alt="rtti_collision" src="http://lh5.ggpht.com/_cWdorEDEaNg/SjdQ6-U2w5I/AAAAAAAAAIA/b5Mr9Zrtq1I/rtti_collision_thumb2.jpg?imgmax=800" width="528" height="190" /></a> </p>  <p>To fix this collision, change the FourCC code of one of the affected classes and recompile.</p>  <p>The other problem is that a class doesn’t register at application startup because the constructor of its static RTTI object has been “optimized away” by the linker. This happens when there’s no actual C++ code in the application which directly uses this class. This is the case if an object is created through N3’s create-by-class-name or create-by-class-fourcc mechanism and the class is only accessed indirectly through virtual method calls.</p>  <p>In this case the linker will drop the .obj module of this class completely since there are no calls from the outside into the object module. That’s a neat optimization to keep the executable size small, and it works great with the static object model of plain C++, but with Nebula3’s dynamic object model we need to trick the linker into linking “unused” classes into the executable. We don’t have to do this for every RefCounted-derived class fortunately, only for specific parts of the inheritance hierarchy (for instance subclasses of ModelNode and ModelNodeInstance in the Render layer, or subclasses of Property in the Application layer)</p>  <p>To prevent the linker from dropping a class the following procedure is recommended: </p>  <ol>   <li>add a __RegisterClass(MyClass) macro to a central .h ‘class registry’ header file </li>    <li>include this header file into a .cc file which definitely won’t be dropped by the linker </li> </ol>  <p>The header file <strong>/nebula3/code/render/render_classregistry.h</strong> is an example for such a centralized class registry header.</p>  